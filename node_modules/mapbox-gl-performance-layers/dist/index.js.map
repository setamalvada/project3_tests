{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///./src/dynamic-data/click-provider/dynamic-r-brush-click-provider.ts","webpack:///./src/dynamic-data/data-operations.ts","webpack:///./src/dynamic-data/dynamic-data-layer.ts","webpack:///./src/dynamic-data/layer-preset/dynamic-point-layer.ts","webpack:///./src/dynamic-data/renderer-preset/dynamic-point-renderer.ts","webpack:///./src/dynamic-data/renderer/dynamic-shader-data-collection.ts","webpack:///./src/dynamic-data/renderer/dynamic-shader-renderer.ts","webpack:///./src/dynamic-data/renderer/dynamic-switch-renderer.ts","webpack:///./src/dynamic-data/renderer/dynamic-tiled-renderer.ts","webpack:///./src/dynamic-data/vertex-data-mapper/fancy-point-to-vertex-array.ts","webpack:///./src/dynamic-data/vertex-data-mapper/simple-point-to-vertex-array.ts","webpack:///./src/index.ts","webpack:///./src/shared/click-handler/line-click-handler.ts","webpack:///./src/shared/click-handler/point-click-handler.ts","webpack:///./src/shared/click-handler/polygon-click-handler.ts","webpack:///./src/shared/geometry-functions.ts","webpack:///./src/shared/shader/default/default-shader.ts","webpack:///./src/shared/shader/default/default.frag","webpack:///./src/shared/shader/default/default.vert","webpack:///./src/shared/shader/line/fancy-line-shader.ts","webpack:///./src/shared/shader/line/fancy-line.frag","webpack:///./src/shared/shader/line/fancy-line.vert","webpack:///./src/shared/shader/line/simple-line-shader.ts","webpack:///./src/shared/shader/point/fancy-point-shader.ts","webpack:///./src/shared/shader/point/fancy-point.frag","webpack:///./src/shared/shader/point/fancy-point.vert","webpack:///./src/shared/shader/point/simple-point-shader.ts","webpack:///./src/shared/shader/point/simple-point.frag","webpack:///./src/shared/shader/point/simple-point.vert","webpack:///./src/shared/shader/polygon/fancy-polygon-shader.ts","webpack:///./src/shared/shader/polygon/fancy-polygon.frag","webpack:///./src/shared/shader/polygon/fancy-polygon.vert","webpack:///./src/shared/shader/polygon/simple-polygon-shader.ts","webpack:///./src/shared/shader/shader.ts","webpack:///./src/shared/shader/texture-drawer/texture-drawer.frag","webpack:///./src/shared/shader/texture-drawer/texture-drawer.ts","webpack:///./src/shared/shader/texture-drawer/texture-drawer.vert","webpack:///./src/shared/styles.ts","webpack:///./src/shared/tile/tile-generator.ts","webpack:///./src/shared/tile/tile-manager.ts","webpack:///./src/shared/tile/tile-renderer.ts","webpack:///./src/shared/visibility.ts","webpack:///./src/static-data/click-provider/kd-bush-click-provider.ts","webpack:///./src/static-data/click-provider/r-bush-click-provider.ts","webpack:///./src/static-data/layer-preset/line-layer.ts","webpack:///./src/static-data/layer-preset/point-layer.ts","webpack:///./src/static-data/layer-preset/polygon-layer.ts","webpack:///./src/static-data/renderer-preset/line-renderer.ts","webpack:///./src/static-data/renderer-preset/point-renderer.ts","webpack:///./src/static-data/renderer-preset/polygon-renderer.ts","webpack:///./src/static-data/renderer/shader-renderer.ts","webpack:///./src/static-data/renderer/switch-renderer.ts","webpack:///./src/static-data/renderer/tiled-renderer.ts","webpack:///./src/static-data/static-data-layer.ts","webpack:///./src/static-data/vertex-data-mapper/fancy-lines-to-shader-buffers.ts","webpack:///./src/static-data/vertex-data-mapper/fancy-points-to-shader-buffers.ts","webpack:///./src/static-data/vertex-data-mapper/fancy-polygons-to-shader-buffers.ts","webpack:///./src/static-data/vertex-data-mapper/simple-lines-to-shader-buffers.ts","webpack:///./src/static-data/vertex-data-mapper/simple-points-to-shader-buffers.ts","webpack:///./src/static-data/vertex-data-mapper/simple-polygons-to-shader-buffers.ts","webpack:///external \"earcut\"","webpack:///external \"gl-matrix\"","webpack:///external \"kdbush\"","webpack:///external \"rbush\""],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA0B;AACoC;AACF;AACrD;AACP;AACA;AACA;AACA;AACA,wBAAwB,4CAAK;AAC7B;AACA;AACA;AACA;AACA;AACA,+BAA+B,8EAAW;AAC1C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,0DAA0D,8EAAW;AACrE;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,4EAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrGA;AAAA;AAAA;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9HA;AAAA;AAAA;AAAA;AAAyD;AACE;AACpD;AACP;AACA;AACA;AACA;AACA,kCAAkC,uEAAsB;AACxD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4EAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAiF;AACxB;AACmC;AACE;AACvF;AACP,eAAe,oEAAgB;AAC/B;AACA,kBAAkB,oGAAoB;AACtC;AACA,gBAAgB,yGAA0B,CAAC,4GAA0B;AACrE,KAAK;AACL;;;;;;;;;;;;;ACXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAkF;AACF;AACc;AACF;AAChB;AACA;AACF;AACnE;AACP;AACA;AACA,YAAY,uFAAqB,KAAK,0FAAiB,yBAAyB,yGAAwB;AACxG,YAAY,uFAAqB,KAAK,wFAAgB,yBAAyB,uGAAuB;AACtG;AACA,eAAe,uFAAqB;AACpC;AACA;AACA;AACA,SAAS;AACT;AACA,0BAA0B,qFAAoB;AAC9C;AACA;AACA;AACA;;;;;;;;;;;;;ACvBA;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzEA;AAAA;AAAA;AAAA;AAAA;AAAiE;AACL;AACmB;AACxE;AACP;AACA;AACA;AACA;AACA,8BAA8B,2FAA2B;AACzD,kCAAkC,uEAAsB;AACxD;AACA;AACA;AACA;AACA;AACA,uBAAuB,iFAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3CA;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtJA;AAAA;AAAA;AAAA;AAA+D;AACyB;AACjF;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uEAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oFAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qFAAkB;AAC9B;AACA;AACA;;;;;;;;;;;;;AC9FA;AAAA;AAAA;AAAA;AAAwD;AACiB;AACzE;AACO;AACP;AACA,IAAI,wEAAiB;AACrB;AACA,mBAAmB,6EAAU,aAAa,6EAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpBA;AAAA;AAAA;AAAA;AAAwD;AACiB;AACzE;AACO;AACP;AACA,IAAI,wEAAiB;AACrB;AACA,mBAAmB,6EAAU,aAAa,6EAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAkE;AACE;AACF;AACM;AACH;AACe;;;;;;;;;;;;;ACLpF;AAAA;AAAA;AAAoF;AAC7E;AACP;AACA;AACA;AACA,8BAA8B;AAC9B,uBAAuB;AACvB;AACA,YAAY,8EAAkB;AAC9B,gCAAgC,mFAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtBA;AAAA;AAAA;AAAqE;AAC9D;AACP;AACA;AACA;AACA;AACA,gCAAgC,wFAA4B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjBA;AAAA;AAAA;AAAyD;AAClD;AACP;AACA;AACA;AACA;AACA,+CAA+C,4EAAgB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACfA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACZ;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,mBAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA0C;AACE;AACrC;AACP;AACA,4BAA4B,oDAAY;AACxC,8BAA8B,oDAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1BA,0CAA0C,6BAA6B,qBAAqB,+BAA+B,KAAK,K;;;;;;;;;;;ACAhI,0CAA0C,8BAA8B,kCAAkC,2BAA2B,6BAA6B,qBAAqB,0BAA0B,4DAA4D,KAAK,K;;;;;;;;;;;;ACAlR;AAAA;AAAA;AAAA;AAAA;AAAA;AAA6C;AACE;AACxC;AACP;AACA;AACA,4BAA4B,uDAAY;AACxC,8BAA8B,uDAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrDA,0CAA0C,sCAAsC,iCAAiC,gCAAgC,yBAAyB,gCAAgC,6BAA6B,qBAAqB,qCAAqC,wCAAwC,iFAAiF,wDAAwD,8EAA8E,uDAAuD,8CAA8C,KAAK,K;;;;;;;;;;;ACA1oB,0CAA0C,8BAA8B,gCAAgC,0CAA0C,qCAAqC,kCAAkC,2BAA2B,kCAAkC,2BAA2B,kCAAkC,iCAAiC,gCAAgC,yBAAyB,gCAAgC,6BAA6B,qBAAqB,uCAAuC,2CAA2C,0BAA0B,wCAAwC,kDAAkD,mFAAmF,6EAA6E,uEAAuE,8FAA8F,uFAAuF,8EAA8E,kEAAkE,0DAA0D,8CAA8C,0CAA0C,sDAAsD,iGAAiG,yGAAyG,KAAK,K;;;;;;;;;;;;ACAxoD;AAAA;AAAA;AAA0D;AACnD,+BAA+B,qEAAa;AACnD;AACA;AACA;AACA;;;;;;;;;;;;;ACLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA8C;AACE;AACzC;AACP;AACA;AACA,4BAA4B,wDAAY;AACxC,8BAA8B,wDAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3CA,0CAA0C,sCAAsC,6BAA6B,yBAAyB,gCAAgC,gCAAgC,8BAA8B,6BAA6B,qBAAqB,2EAA2E,wCAAwC,iFAAiF,wDAAwD,8EAA8E,uDAAuD,8CAA8C,KAAK,K;;;;;;;;;;;ACA1sB,0CAA0C,8BAA8B,kCAAkC,2BAA2B,2BAA2B,kCAAkC,kCAAkC,6BAA6B,yBAAyB,gCAAgC,gCAAgC,8BAA8B,6BAA6B,qBAAqB,wBAAwB,0BAA0B,sCAAsC,wCAAwC,iDAAiD,gCAAgC,gEAAgE,mCAAmC,KAAK,K;;;;;;;;;;;;ACAnuB;AAAA;AAAA;AAAA;AAAA;AAAA;AAA+C;AACE;AAC1C;AACP;AACA;AACA,4BAA4B,yDAAY;AACxC,8BAA8B,yDAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnCA,0CAA0C,sCAAsC,6BAA6B,yBAAyB,6BAA6B,qBAAqB,sEAAsE,oCAAoC,uDAAuD,+DAA+D,KAAK,K;;;;;;;;;;;ACA7Z,0CAA0C,8BAA8B,kCAAkC,2BAA2B,2BAA2B,6BAA6B,yBAAyB,6BAA6B,qBAAqB,wBAAwB,0BAA0B,gCAAgC,gEAAgE,8BAA8B,KAAK,K;;;;;;;;;;;;ACA7b;AAAA;AAAA;AAAA;AAAA;AAAA;AAAgD;AACE;AAC3C;AACP;AACA;AACA,4BAA4B,0DAAY;AACxC,8BAA8B,0DAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrDA,0CAA0C,sCAAsC,6BAA6B,gCAAgC,yBAAyB,6BAA6B,qBAAqB,mDAAmD,4DAA4D,uEAAuE,+DAA+D,sDAAsD,8CAA8C,KAAK,K;;;;;;;;;;;ACAtjB,0CAA0C,8BAA8B,gCAAgC,kCAAkC,0CAA0C,qCAAqC,kCAAkC,kCAAkC,6BAA6B,2BAA2B,kCAAkC,6BAA6B,gCAAgC,yBAAyB,6BAA6B,qBAAqB,0BAA0B,wCAAwC,iDAAiD,uCAAuC,mFAAmF,6EAA6E,uEAAuE,8FAA8F,uFAAuF,8EAA8E,kEAAkE,0DAA0D,8CAA8C,0CAA0C,sDAAsD,iGAAiG,yGAAyG,KAAK,K;;;;;;;;;;;;ACA5lD;AAAA;AAAA;AAA0D;AACnD,kCAAkC,qEAAa;AACtD;AACA;AACA;AACA;;;;;;;;;;;;;ACLA;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClCA,0CAA0C,oCAAoC,yCAAyC,qBAAqB,iEAAiE,KAAK,K;;;;;;;;;;;;ACAlN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAgD;AACC;AACE;AAC5C;AACP;AACA;AACA;AACA;AACA;AACA,uBAAuB,mEAAmB,KAAK,2DAAY,EAAE,2DAAc;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5DA,0CAA0C,8BAA8B,gCAAgC,kCAAkC,uCAAuC,yCAAyC,qBAAqB,kDAAkD,4DAA4D,KAAK,K;;;;;;;;;;;;ACAlW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAO;AACP;AACA,YAAY,mBAAmB;AAC/B;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACO;AACP;AACA,YAAY,mBAAmB;AAC/B;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACO;AACP,YAAY,mBAAmB;AAC/B;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpDA;AAAA;AAAA;AAAA;AAAsC;AAC/B;AACP;AACA;AACA;AACA,sBAAsB,8CAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8CAAa;AACrB;AACA;;;;;;;;;;;;;ACvCA;AAAA;AAAA;AAA+D;AACxD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sEAAU;AAC3B,iBAAiB,sEAAU;AAC3B,iBAAiB,sEAAU;AAC3B,iBAAiB,sEAAU;AAC3B;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9GA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA6C;AAC2B;AACvB;AACM;AAChD;AACP;AACA;AACA,iCAAiC,mFAAa;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yDAAW,KAAK,6DAAa;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0EAAc;AACtB;AACA;AACA;AACA,oDAAoD,wBAAwB;AAC5E,wDAAwD,wBAAwB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClEA;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACbA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4D;AACc;AAC9C;AACrB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,4EAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,0FAAuB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,6CAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA0B;AACoC;AACF;AACrD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,4EAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iEAAiE,8EAAW;AAC5E,wBAAwB,4CAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAgE;AACT;AACmC;AACb;AACtE;AACP,eAAe,kEAAe;AAC9B;AACA,kBAAkB,mFAAY;AAC9B;AACA,gBAAgB,wFAAkB,CAAC,0GAAyB;AAC5D,KAAK;AACL;;;;;;;;;;;;;ACXA;AAAA;AAAA;AAAA;AAAA;AAAkE;AACX;AACwB;AACxE;AACP,eAAe,kEAAe;AAC9B;AACA,kBAAkB,qFAAa;AAC/B;AACA,gBAAgB,0FAAmB;AACnC,KAAK;AACL;;;;;;;;;;;;;ACVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAsE;AACf;AACyC;AACnB;AACtE;AACP,eAAe,kEAAe;AAC9B;AACA,kBAAkB,yFAAe;AACjC;AACA,gBAAgB,wFAAkB,CAAC,gHAA4B;AAC/D,KAAK;AACL;;;;;;;;;;;;;ACXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA6E;AACE;AAClB;AACA;AACF;AACuC;AACF;AACzF;AACP;AACA,kCAAkC,uFAAgB,SAAS,qFAAe;AAC1E,kCAAkC,6GAA0B,GAAG,2GAAyB;AACxF;AACA,eAAe,wEAAc;AAC7B;AACA,0BAA0B,wEAAc;AACxC;AACA,SAAS;AACT;AACA,0BAA0B,sEAAa,KAAK,wEAAc;AAC1D;AACA;AACA;AACA;;;;;;;;;;;;;ACtBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAgF;AACE;AACrB;AACA;AACF;AACyC;AACF;AAC3F;AACP;AACA,kCAAkC,0FAAiB,8BAA8B,wFAAgB;AACjG,kCAAkC,+GAA2B,GAAG,6GAA0B;AAC1F;AACA,eAAe,wEAAc;AAC7B;AACA,0BAA0B,wEAAc;AACxC;AACA,SAAS;AACT;AACA,0BAA0B,sEAAa,KAAK,wEAAc;AAC1D;AACA;AACA;AACA;;;;;;;;;;;;;ACtBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAsF;AACE;AAC3B;AACA;AACF;AAC6C;AACF;AAC/F;AACP;AACA,kCAAkC,gGAAmB,SAAS,8FAAkB;AAChF,kCAAkC,mHAA6B,GAAG,iHAA4B;AAC9F;AACA,eAAe,wEAAc;AAC7B;AACA,0BAA0B,wEAAc;AACxC;AACA,SAAS;AACT;AACA,0BAA0B,sEAAa,KAAK,wEAAc;AAC1D;AACA;AACA;AACA;;;;;;;;;;;;;ACtBA;AAAA;AAAA;AAAiE;AAC1D;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iFAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxDA;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3DA;AAAA;AAAA;AAAA;AAA8E;AACf;AACxD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uEAAY;AAC5C;AACA;AACA,QAAQ,8FAA2B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjCA;AAAA;AAAA;AAAyD;AAClD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4EAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5FA;AAAA;AAAA;AAAA;AAAuD;AACoC;AACpF;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C,6BAA6B,6EAAU;AACvC,6BAA6B,6EAAU;AACvC;AACA;AACA,wBAAwB,6EAAU;AAClC,wBAAwB,6EAAU;AAClC;AACA;AACA;AACA;AACA,4BAA4B,6EAAU;AACtC,4BAA4B,6EAAU;AACtC;AACA;AACA;AACA;AACA,4BAA4B,6EAAU;AACtC,4BAA4B,6EAAU;AACtC,wBAAwB,6EAAU;AAClC,wBAAwB,6EAAU;AAClC;AACA,6BAA6B,mFAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uEAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvEA;AAAA;AAAA;AAAA;AAAwD;AACiB;AAClE;AACP;AACA;AACA,mBAAmB,6EAAU,aAAa,6EAAU;AACpD;AACA;AACA;AACA,QAAQ,wEAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA0D;AACiC;AAC/D;AACrB;AACP;AACA;AACA;AACA;AACA;AACA,wEAAwE,6EAAU,aAAa,6EAAU;AACzG;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mFAAgB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,6CAAM;AAC3B,0BAA0B,6CAAM;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0EAAmB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpEA;AAAA;AAAA;AAAA;AAAuD;AACkB;AAClE;AACP;AACA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA,uBAAuB,6EAAU,aAAa,6EAAU;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uEAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrCA;AAAA;AAAA;AAAA;AAAwD;AACiB;AAClE;AACP;AACA;AACA,mBAAmB,6EAAU,aAAa,6EAAU;AACpD;AACA;AACA;AACA,QAAQ,wEAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA0D;AACe;AAC7C;AACrB;AACP;AACA;AACA;AACA;AACA,6EAA6E,6EAAU,aAAa,6EAAU;AAC9G,qBAAqB,6CAAM;AAC3B,uBAAuB,0BAA0B;AACjD;AACA;AACA,0BAA0B,6CAAM;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0EAAmB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrCA,oD;;;;;;;;;;;ACAA,uD;;;;;;;;;;;ACAA,oD;;;;;;;;;;;ACAA,mD","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"earcut\"), require(\"gl-matrix\"), require(\"kdbush\"), require(\"rbush\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"earcut\", \"gl-matrix\", \"kdbush\", \"rbush\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"earcut\"), require(\"gl-matrix\"), require(\"kdbush\"), require(\"rbush\")) : factory(root[\"earcut\"], root[\"gl-matrix\"], root[\"kdbush\"], root[\"rbush\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(window, function(__WEBPACK_EXTERNAL_MODULE_earcut__, __WEBPACK_EXTERNAL_MODULE_gl_matrix__, __WEBPACK_EXTERNAL_MODULE_kdbush__, __WEBPACK_EXTERNAL_MODULE_rbush__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.ts\");\n","import RBush from 'rbush';\r\nimport { packFeature } from '../../shared/geometry-functions';\r\nimport { resolveVisibility } from '../../shared/visibility';\r\nexport class DynamicRBrushClickProvider {\r\n    constructor(resultsHandler, clickSize) {\r\n        this.resultsHandler = resultsHandler;\r\n        this.clickSize = clickSize;\r\n        this.packedFeatures = [];\r\n        this.tree = new RBush();\r\n        this.map = null;\r\n        this.visibility = true;\r\n        this.currentIndex = 0;\r\n        this.dataOperations = {\r\n            add: (feature) => {\r\n                const packed = packFeature(feature, this.currentIndex);\r\n                this.currentIndex++;\r\n                this.packedFeatures.push(packed);\r\n                this.tree.insert(packed);\r\n            },\r\n            removeFirst: () => {\r\n                const packed = this.packedFeatures.shift();\r\n                if (packed != null) {\r\n                    this.tree.remove(packed);\r\n                }\r\n                return packed != null ? packed.feature : null;\r\n            },\r\n            removeLast: () => {\r\n                const packed = this.packedFeatures.pop();\r\n                if (packed != null) {\r\n                    this.tree.remove(packed);\r\n                }\r\n                return packed != null ? packed.feature : null;\r\n            },\r\n            clear: () => {\r\n                this.packedFeatures.length = 0;\r\n                this.tree.clear();\r\n            },\r\n            getArray: () => {\r\n                return this.packedFeatures.map(p => p.feature);\r\n            },\r\n            addAll: (features) => {\r\n                const packed = features.map((f, index) => packFeature(f, this.currentIndex + index));\r\n                this.currentIndex += features.length;\r\n                this.packedFeatures.push(...packed);\r\n                this.tree.load(packed);\r\n            },\r\n            removeNFirst: (n) => {\r\n                let removed = [];\r\n                for (let i = 0; i < n; i++) {\r\n                    const r = this.dataOperations.removeFirst();\r\n                    if (r != null) {\r\n                        removed.push(r);\r\n                    }\r\n                }\r\n                return removed;\r\n            },\r\n            removeNLast: (n) => {\r\n                let removed = [];\r\n                for (let i = 0; i < n; i++) {\r\n                    const r = this.dataOperations.removeLast();\r\n                    if (r != null) {\r\n                        removed.unshift(r);\r\n                    }\r\n                }\r\n                return removed;\r\n            }\r\n        };\r\n        this.clickHandler = (e) => {\r\n            if (this.map == null || this.tree == null) {\r\n                return;\r\n            }\r\n            if (!resolveVisibility(this.visibility, this.map)) {\r\n                return;\r\n            }\r\n            const bounds = this.map.getBounds();\r\n            const canvas = this.map.getCanvas();\r\n            const clickSize = this.clickSize != null ? this.clickSize : 16;\r\n            const x = e.lngLat.lng;\r\n            const y = e.lngLat.lat;\r\n            const w = clickSize * (bounds.getEast() - bounds.getWest()) / canvas.width;\r\n            const h = clickSize * (bounds.getNorth() - bounds.getSouth()) / canvas.height;\r\n            const results = this.tree.search({\r\n                minX: x - 0.5 * w,\r\n                minY: y - 0.5 * h,\r\n                maxX: x + 0.5 * w,\r\n                maxY: y + 0.5 * h\r\n            });\r\n            this.resultsHandler(x, y, Math.max(w, h), results, e);\r\n        };\r\n    }\r\n    initialise(map) {\r\n        this.map = map;\r\n        map.on('click', this.clickHandler);\r\n    }\r\n    dispose(map) {\r\n        this.map = null;\r\n        map.off('click', this.clickHandler);\r\n    }\r\n    setVisibility(visibility) {\r\n        this.visibility = visibility;\r\n    }\r\n}\r\n","export class BaseDataOperationsComposer {\r\n    constructor(sources, onDataChange) {\r\n        this.sources = sources;\r\n        this.onDataChange = onDataChange;\r\n    }\r\n    add(element) {\r\n        for (const source of this.sources) {\r\n            source.add(element);\r\n        }\r\n        if (this.onDataChange != null) {\r\n            this.onDataChange();\r\n        }\r\n    }\r\n    removeFirst() {\r\n        let removed = null;\r\n        for (const source of this.sources) {\r\n            removed = source.removeFirst();\r\n        }\r\n        if (this.onDataChange != null) {\r\n            this.onDataChange();\r\n        }\r\n        return removed;\r\n    }\r\n    removeLast() {\r\n        let removed = null;\r\n        for (const source of this.sources) {\r\n            removed = source.removeLast();\r\n        }\r\n        if (this.onDataChange != null) {\r\n            this.onDataChange();\r\n        }\r\n        return removed;\r\n    }\r\n    clear() {\r\n        for (const source of this.sources) {\r\n            source.clear();\r\n        }\r\n        if (this.onDataChange != null) {\r\n            this.onDataChange();\r\n        }\r\n    }\r\n    getArray() {\r\n        if (this.sources.length == 0) {\r\n            throw Error('No data sources provided.');\r\n        }\r\n        return this.sources[0].getArray();\r\n    }\r\n}\r\nexport class DataOperationsComposer extends BaseDataOperationsComposer {\r\n    constructor(sources, onDataChange) {\r\n        super(sources, onDataChange);\r\n        this.sources = sources;\r\n    }\r\n    addAll(elements) {\r\n        for (const source of this.sources) {\r\n            source.addAll(elements);\r\n        }\r\n        if (this.onDataChange != null) {\r\n            this.onDataChange();\r\n        }\r\n    }\r\n    removeNFirst(n) {\r\n        let removed = null;\r\n        for (const source of this.sources) {\r\n            removed = source.removeNFirst(n);\r\n        }\r\n        if (this.onDataChange != null) {\r\n            this.onDataChange();\r\n        }\r\n        return removed != null ? removed : [];\r\n    }\r\n    removeNLast(n) {\r\n        let removed = null;\r\n        for (const source of this.sources) {\r\n            removed = source.removeNLast(n);\r\n        }\r\n        if (this.onDataChange != null) {\r\n            this.onDataChange();\r\n        }\r\n        return removed != null ? removed : [];\r\n    }\r\n}\r\nexport class DataOperationsExtender {\r\n    constructor(source) {\r\n        this.source = source;\r\n    }\r\n    add(element) {\r\n        this.source.add(element);\r\n    }\r\n    removeFirst() {\r\n        return this.source.removeFirst();\r\n    }\r\n    removeLast() {\r\n        return this.source.removeLast();\r\n    }\r\n    clear() {\r\n        this.source.clear();\r\n    }\r\n    getArray() {\r\n        return this.source.getArray();\r\n    }\r\n    addAll(elements) {\r\n        for (const element of elements) {\r\n            this.source.add(element);\r\n        }\r\n    }\r\n    removeNFirst(n) {\r\n        let removed = [];\r\n        for (let i = 0; i < n; i++) {\r\n            const r = this.source.removeFirst();\r\n            if (r != null) {\r\n                removed.push(r);\r\n            }\r\n        }\r\n        return removed;\r\n    }\r\n    removeNLast(n) {\r\n        let removed = [];\r\n        for (let i = 0; i < n; i++) {\r\n            const r = this.source.removeLast();\r\n            if (r != null) {\r\n                removed.unshift(r);\r\n            }\r\n        }\r\n        return removed;\r\n    }\r\n}\r\n","import { resolveVisibility } from '../shared/visibility';\r\nimport { DataOperationsComposer } from './data-operations';\r\nexport class DynamicDataLayer {\r\n    constructor(options) {\r\n        this.options = options;\r\n        this.map = null;\r\n        this.visibility = true;\r\n        this.dataOperations = new DataOperationsComposer(this.options.clickProvider != null ?\r\n            [this.options.renderer.dataOperations, this.options.clickProvider.dataOperations] :\r\n            [this.options.renderer.dataOperations], () => {\r\n            if (this.map != null) {\r\n                this.map.triggerRepaint();\r\n            }\r\n        });\r\n    }\r\n    get id() {\r\n        return this.options.id;\r\n    }\r\n    get renderingMode() {\r\n        if (this.options.renderingMode == null) {\r\n            return '2d';\r\n        }\r\n        return this.options.renderingMode;\r\n    }\r\n    get type() {\r\n        return 'custom';\r\n    }\r\n    setStyle(styleOption) {\r\n        this.options.renderer.setStyle(styleOption);\r\n    }\r\n    setVisibility(visibility) {\r\n        this.visibility = visibility;\r\n        if (this.options.clickProvider != null) {\r\n            this.options.clickProvider.setVisibility(visibility);\r\n        }\r\n        if (this.map != null) {\r\n            this.map.triggerRepaint();\r\n        }\r\n    }\r\n    isVisible() {\r\n        return resolveVisibility(this.visibility, this.map);\r\n    }\r\n    onAdd(map, gl) {\r\n        this.map = map;\r\n        this.options.renderer.initialise(map, gl);\r\n        if (this.options.clickProvider != null) {\r\n            this.options.clickProvider.initialise(map);\r\n        }\r\n    }\r\n    onRemove(map, gl) {\r\n        this.map = null;\r\n        this.options.renderer.dispose(map, gl);\r\n        if (this.options.clickProvider != null) {\r\n            this.options.clickProvider.dispose(map);\r\n        }\r\n    }\r\n    prerender(gl, matrix) {\r\n        if (this.isVisible()) {\r\n            this.options.renderer.prerender(gl, matrix);\r\n        }\r\n    }\r\n    render(gl, matrix) {\r\n        if (this.isVisible()) {\r\n            this.options.renderer.render(gl, matrix);\r\n        }\r\n    }\r\n}\r\n","import { dynamicPointRenderer } from '../renderer-preset/dynamic-point-renderer';\r\nimport { DynamicDataLayer } from '../dynamic-data-layer';\r\nimport { pointToResultsClickHandler } from '../../shared/click-handler/point-click-handler';\r\nimport { DynamicRBrushClickProvider } from '../click-provider/dynamic-r-brush-click-provider';\r\nexport function dynamicPointLayer(options) {\r\n    return new DynamicDataLayer({\r\n        id: options.id,\r\n        renderer: dynamicPointRenderer(options),\r\n        clickProvider: options.onClick != null ?\r\n            new DynamicRBrushClickProvider(pointToResultsClickHandler(options.onClick), options.clickSize) : undefined\r\n    });\r\n}\r\n","import { SimplePointShader } from '../../shared/shader/point/simple-point-shader';\r\nimport { FancyPointShader } from '../../shared/shader/point/fancy-point-shader';\r\nimport { simplePointToVertexArray } from '../vertex-data-mapper/simple-point-to-vertex-array';\r\nimport { fancyPointToVertexArray } from '../vertex-data-mapper/fancy-point-to-vertex-array';\r\nimport { DynamicShaderRenderer } from '../renderer/dynamic-shader-renderer';\r\nimport { DynamicSwitchRenderer } from '../renderer/dynamic-switch-renderer';\r\nimport { DynamicTiledRenderer } from '../renderer/dynamic-tiled-renderer';\r\nexport function dynamicPointRenderer(options) {\r\n    const isSimple = options.simpleRendering != null && options.simpleRendering;\r\n    const shaderRenderer = isSimple ?\r\n        new DynamicShaderRenderer(new SimplePointShader(options.interpolation), simplePointToVertexArray) :\r\n        new DynamicShaderRenderer(new FancyPointShader(options.interpolation), fancyPointToVertexArray);\r\n    const threshold = options.tileThreshold != null ? options.tileThreshold : 100000;\r\n    return new DynamicSwitchRenderer([\r\n        {\r\n            renderer: shaderRenderer,\r\n            condition: o => o.getArray().length < threshold\r\n        },\r\n        {\r\n            renderer: new DynamicTiledRenderer(shaderRenderer, options),\r\n            condition: o => o.getArray().length >= threshold\r\n        }\r\n    ]);\r\n}\r\n","export class DynamicShaderDataCollection {\r\n    constructor(vertexDataMapper, startingBufferSize) {\r\n        this.vertexDataMapper = vertexDataMapper;\r\n        this.styleOption = undefined;\r\n        this.features = [];\r\n        this.startIndex = 0;\r\n        this.endIndex = 0;\r\n        this.buffer = new Float32Array(startingBufferSize);\r\n    }\r\n    add(feature) {\r\n        const mapped = this.vertexDataMapper(feature, this.styleOption);\r\n        if (this.endIndex + mapped.length >= this.buffer.length) {\r\n            this.resetBuffer();\r\n        }\r\n        this.buffer.set(mapped, this.endIndex);\r\n        this.endIndex += mapped.length;\r\n        this.features.push(feature);\r\n    }\r\n    removeFirst() {\r\n        const feature = this.features.shift();\r\n        if (feature != null) {\r\n            const mapped = this.vertexDataMapper(feature, this.styleOption);\r\n            this.startIndex += mapped.length;\r\n        }\r\n        return feature != null ? feature : null;\r\n    }\r\n    removeLast() {\r\n        const feature = this.features.pop();\r\n        if (feature != null) {\r\n            const mapped = this.vertexDataMapper(feature, this.styleOption);\r\n            this.endIndex -= mapped.length;\r\n        }\r\n        return feature != null ? feature : null;\r\n    }\r\n    clear() {\r\n        this.features.length = 0;\r\n        this.startIndex = 0;\r\n        this.endIndex = 0;\r\n    }\r\n    setStyle(styleOption) {\r\n        this.styleOption = styleOption;\r\n        this.startIndex = 0;\r\n        this.endIndex = 0;\r\n        for (const feature of this.features) {\r\n            const mapped = this.vertexDataMapper(feature, this.styleOption);\r\n            this.buffer.set(mapped, this.endIndex);\r\n            this.endIndex += mapped.length;\r\n        }\r\n    }\r\n    resetBuffer() {\r\n        const currentSize = this.endIndex - this.startIndex;\r\n        this.buffer.copyWithin(0, this.startIndex, this.endIndex);\r\n        this.startIndex = 0;\r\n        this.endIndex = currentSize;\r\n        if (this.buffer.length >= 2 * currentSize) {\r\n            return;\r\n        }\r\n        const newBuffer = new Float32Array(2 * this.buffer.length);\r\n        newBuffer.set(this.buffer);\r\n        this.buffer = newBuffer;\r\n    }\r\n    getArray() {\r\n        return this.features;\r\n    }\r\n    getVertexArray() {\r\n        return this.buffer;\r\n    }\r\n    getStartIndex() {\r\n        return this.startIndex;\r\n    }\r\n    getEndIndex() {\r\n        return this.endIndex;\r\n    }\r\n}\r\n","import { createShaderProgram } from '../../shared/shader/shader';\r\nimport { DataOperationsExtender } from '../data-operations';\r\nimport { DynamicShaderDataCollection } from './dynamic-shader-data-collection';\r\nexport class DynamicShaderRenderer {\r\n    constructor(shader, vertexDataMapper, startingBufferSize = 512) {\r\n        this.shader = shader;\r\n        this.program = null;\r\n        this.arrayBuffer = null;\r\n        this.collection = new DynamicShaderDataCollection(vertexDataMapper, startingBufferSize);\r\n        this.dataOperations = new DataOperationsExtender(this.collection);\r\n    }\r\n    setStyle(styleOption) {\r\n        this.collection.setStyle(styleOption);\r\n    }\r\n    initialise(map, gl) {\r\n        this.program = createShaderProgram(gl, this.shader.vertexSource, this.shader.fragmentSource);\r\n        this.arrayBuffer = gl.createBuffer();\r\n    }\r\n    dispose(map, gl) {\r\n        gl.deleteBuffer(this.arrayBuffer);\r\n        gl.deleteProgram(this.program);\r\n    }\r\n    prerender() {\r\n    }\r\n    render(gl, matrix) {\r\n        if (this.program == null) {\r\n            throw Error('ShaderRenderer can not render before it is initialised.');\r\n        }\r\n        gl.enable(gl.BLEND);\r\n        gl.blendEquation(gl.FUNC_ADD);\r\n        gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\r\n        gl.useProgram(this.program);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.arrayBuffer);\r\n        const cleanAttributes = this.shader.configureAttributes(gl, this.program);\r\n        gl.bufferData(gl.ARRAY_BUFFER, this.collection.getVertexArray(), gl.STATIC_DRAW);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\r\n        this.shader.setUniforms(gl, this.program, matrix);\r\n        const startIndex = this.collection.getStartIndex();\r\n        const endIndex = this.collection.getEndIndex();\r\n        const elementsPerVertex = this.shader.getArrayBufferElementsPerVertex();\r\n        gl.drawArrays(this.shader.getPrimitiveType(gl), startIndex / elementsPerVertex, (endIndex - startIndex) / elementsPerVertex);\r\n        cleanAttributes();\r\n    }\r\n}\r\n","export class DynamicSwitchRenderer {\r\n    constructor(options, broadcastData = false) {\r\n        this.options = options;\r\n        this.broadcastData = broadcastData;\r\n        this.map = null;\r\n        this.gl = null;\r\n        this.currentOption = null;\r\n        this.dataOperations = {\r\n            add: (element) => {\r\n                if (this.broadcastData) {\r\n                    for (const option of this.options) {\r\n                        option.renderer.dataOperations.add(element);\r\n                    }\r\n                }\r\n                else if (this.currentOption != null) {\r\n                    this.currentOption.renderer.dataOperations.add(element);\r\n                }\r\n                this.handleDataChange();\r\n            },\r\n            removeFirst: () => {\r\n                let removed = null;\r\n                if (this.broadcastData) {\r\n                    for (const option of this.options) {\r\n                        removed = option.renderer.dataOperations.removeFirst();\r\n                    }\r\n                }\r\n                else if (this.currentOption != null) {\r\n                    removed = this.currentOption.renderer.dataOperations.removeFirst();\r\n                }\r\n                this.handleDataChange();\r\n                return removed;\r\n            },\r\n            removeLast: () => {\r\n                let removed = null;\r\n                if (this.broadcastData) {\r\n                    for (const option of this.options) {\r\n                        removed = option.renderer.dataOperations.removeLast();\r\n                    }\r\n                }\r\n                else if (this.currentOption != null) {\r\n                    removed = this.currentOption.renderer.dataOperations.removeLast();\r\n                }\r\n                this.handleDataChange();\r\n                return removed;\r\n            },\r\n            clear: () => {\r\n                if (this.broadcastData) {\r\n                    for (const option of this.options) {\r\n                        option.renderer.dataOperations.clear();\r\n                    }\r\n                }\r\n                else if (this.currentOption != null) {\r\n                    this.currentOption.renderer.dataOperations.clear();\r\n                }\r\n                this.handleDataChange();\r\n            },\r\n            getArray: () => {\r\n                if (this.currentOption != null) {\r\n                    return this.currentOption.renderer.dataOperations.getArray();\r\n                }\r\n                return [];\r\n            },\r\n            addAll: (elements) => {\r\n                if (this.broadcastData) {\r\n                    for (const option of this.options) {\r\n                        option.renderer.dataOperations.addAll(elements);\r\n                    }\r\n                }\r\n                else if (this.currentOption != null) {\r\n                    this.currentOption.renderer.dataOperations.addAll(elements);\r\n                }\r\n                this.handleDataChange();\r\n            },\r\n            removeNFirst: (n) => {\r\n                let removed = null;\r\n                if (this.broadcastData) {\r\n                    for (const option of this.options) {\r\n                        removed = option.renderer.dataOperations.removeNFirst(n);\r\n                    }\r\n                }\r\n                else if (this.currentOption != null) {\r\n                    removed = this.currentOption.renderer.dataOperations.removeNFirst(n);\r\n                }\r\n                this.handleDataChange();\r\n                return removed != null ? removed : [];\r\n            },\r\n            removeNLast: (n) => {\r\n                let removed = null;\r\n                if (this.broadcastData) {\r\n                    for (const option of this.options) {\r\n                        removed = option.renderer.dataOperations.removeNLast(n);\r\n                    }\r\n                }\r\n                else if (this.currentOption != null) {\r\n                    removed = this.currentOption.renderer.dataOperations.removeNLast(n);\r\n                }\r\n                this.handleDataChange();\r\n                return removed != null ? removed : [];\r\n            }\r\n        };\r\n        this.handleDataChange();\r\n    }\r\n    setStyle(styleOption) {\r\n        for (const option of this.options) {\r\n            option.renderer.setStyle(styleOption);\r\n        }\r\n    }\r\n    initialise(map, gl) {\r\n        if (this.currentOption != null) {\r\n            this.currentOption.renderer.initialise(map, gl);\r\n        }\r\n        this.map = map;\r\n        this.gl = gl;\r\n    }\r\n    dispose(map, gl) {\r\n        this.gl = null;\r\n        this.map = null;\r\n        if (this.currentOption != null) {\r\n            this.currentOption.renderer.dispose(map, gl);\r\n        }\r\n    }\r\n    prerender(gl, matrix) {\r\n        if (this.currentOption != null) {\r\n            this.currentOption.renderer.prerender(gl, matrix);\r\n        }\r\n    }\r\n    render(gl, matrix) {\r\n        if (this.currentOption != null) {\r\n            this.currentOption.renderer.render(gl, matrix);\r\n        }\r\n    }\r\n    handleDataChange() {\r\n        const currentOption = this.currentOption;\r\n        if (currentOption != null && currentOption.condition(currentOption.renderer.dataOperations)) {\r\n            return;\r\n        }\r\n        const newOption = this.options.find(option => option.condition(option.renderer.dataOperations));\r\n        if (newOption === currentOption) {\r\n            return;\r\n        }\r\n        if (this.map != null && this.gl != null) {\r\n            if (currentOption != null) {\r\n                currentOption.renderer.dispose(this.map, this.gl);\r\n            }\r\n            if (newOption != null) {\r\n                newOption.renderer.initialise(this.map, this.gl);\r\n            }\r\n        }\r\n        this.currentOption = newOption != null ? newOption : null;\r\n    }\r\n}\r\n","import { TileRenderer } from '../../shared/tile/tile-renderer';\r\nimport { findFeatureBounds, findFeaturesBounds } from '../../shared/geometry-functions';\r\nexport class DynamicTiledRenderer {\r\n    constructor(renderer, options) {\r\n        this.renderer = renderer;\r\n        this.dataBounds = {\r\n            minX: Infinity,\r\n            minY: Infinity,\r\n            maxX: -Infinity,\r\n            maxY: -Infinity\r\n        };\r\n        this.tempBounds = {\r\n            minX: Infinity,\r\n            minY: Infinity,\r\n            maxX: -Infinity,\r\n            maxY: -Infinity\r\n        };\r\n        this.dataOperations = {\r\n            add: (feature) => {\r\n                this.renderer.dataOperations.add(feature);\r\n                this.handleDataChange(feature);\r\n            },\r\n            removeFirst: () => {\r\n                const feature = this.renderer.dataOperations.removeFirst();\r\n                if (feature != null) {\r\n                    this.handleDataChange(feature);\r\n                }\r\n                return feature;\r\n            },\r\n            removeLast: () => {\r\n                const feature = this.renderer.dataOperations.removeLast();\r\n                if (feature != null) {\r\n                    this.handleDataChange(feature);\r\n                }\r\n                return feature;\r\n            },\r\n            clear: () => {\r\n                this.renderer.dataOperations.clear();\r\n                this.tileRenderer.markAllTilesOutdated();\r\n            },\r\n            getArray: () => {\r\n                return this.renderer.dataOperations.getArray();\r\n            },\r\n            addAll: (features) => {\r\n                this.renderer.dataOperations.addAll(features);\r\n                for (const feature of features) {\r\n                    this.handleDataChange(feature);\r\n                }\r\n            },\r\n            removeNFirst: (n) => {\r\n                const features = this.renderer.dataOperations.removeNFirst(n);\r\n                for (const feature of features) {\r\n                    this.handleDataChange(feature);\r\n                }\r\n                return features;\r\n            },\r\n            removeNLast: (n) => {\r\n                const features = this.renderer.dataOperations.removeNLast(n);\r\n                for (const feature of features) {\r\n                    this.handleDataChange(feature);\r\n                }\r\n                return features;\r\n            }\r\n        };\r\n        this.tileRenderer = new TileRenderer(renderer, options);\r\n    }\r\n    setStyle(styleOption) {\r\n        this.renderer.setStyle(styleOption);\r\n        this.tileRenderer.markAllTilesOutdated();\r\n    }\r\n    initialise(map, gl) {\r\n        this.tileRenderer.initialise(map, gl);\r\n    }\r\n    dispose(map, gl) {\r\n        this.tileRenderer.dispose(map, gl);\r\n    }\r\n    prerender() {\r\n    }\r\n    render(gl, matrix) {\r\n        this.tileRenderer.render(gl, matrix, this.dataBounds);\r\n    }\r\n    handleDataChange(feature) {\r\n        const bounds = this.tempBounds;\r\n        findFeatureBounds(bounds, feature);\r\n        this.tileRenderer.markOutdatedTiles(bounds);\r\n        const dataBoundsChanged = this.dataBounds == null ||\r\n            bounds.minX <= this.dataBounds.minX ||\r\n            bounds.minY <= this.dataBounds.minY ||\r\n            bounds.maxX >= this.dataBounds.maxX ||\r\n            bounds.maxY >= this.dataBounds.maxY;\r\n        if (dataBoundsChanged) {\r\n            findFeaturesBounds(this.dataBounds, this.dataOperations.getArray());\r\n        }\r\n    }\r\n}\r\n","import { resolvePointStyle } from '../../shared/styles';\r\nimport { transformX, transformY } from '../../shared/geometry-functions';\r\nconst style = {};\r\nexport function fancyPointToVertexArray(feature, styleOption) {\r\n    const array = [];\r\n    resolvePointStyle(style, feature, styleOption);\r\n    function processSinglePoint(coords) {\r\n        array.push(transformX(coords[0]), transformY(coords[1]), style.size, style.color.r, style.color.g, style.color.b, style.opacity, style.outlineSize, style.outlineColor.r, style.outlineColor.g, style.outlineColor.b, style.outlineOpacity);\r\n    }\r\n    if (feature.geometry.type === 'Point') {\r\n        const geometry = feature.geometry;\r\n        processSinglePoint(geometry.coordinates);\r\n    }\r\n    else if (feature.geometry.type === 'MultiPoint') {\r\n        const geometry = feature.geometry;\r\n        for (const coords of geometry.coordinates) {\r\n            processSinglePoint(coords);\r\n        }\r\n    }\r\n    return array;\r\n}\r\n","import { resolvePointStyle } from '../../shared/styles';\r\nimport { transformX, transformY } from '../../shared/geometry-functions';\r\nconst style = {};\r\nexport function simplePointToVertexArray(feature, styleOption) {\r\n    const array = [];\r\n    resolvePointStyle(style, feature, styleOption);\r\n    function processSinglePoint(coords) {\r\n        array.push(transformX(coords[0]), transformY(coords[1]), style.size, style.color.r, style.color.g, style.color.b, style.opacity);\r\n    }\r\n    if (feature.geometry.type === 'Point') {\r\n        const geometry = feature.geometry;\r\n        processSinglePoint(geometry.coordinates);\r\n    }\r\n    else if (feature.geometry.type === 'MultiPoint') {\r\n        const geometry = feature.geometry;\r\n        for (const coords of geometry.coordinates) {\r\n            processSinglePoint(coords);\r\n        }\r\n    }\r\n    return array;\r\n}\r\n","export { StaticDataLayer } from './static-data/static-data-layer';\r\nexport { pointLayer } from './static-data/layer-preset/point-layer';\r\nexport { lineLayer } from './static-data/layer-preset/line-layer';\r\nexport { polygonLayer } from './static-data/layer-preset/polygon-layer';\r\nexport { DynamicDataLayer } from './dynamic-data/dynamic-data-layer';\r\nexport { dynamicPointLayer } from './dynamic-data/layer-preset/dynamic-point-layer';\r\n","import { closestPointOnLine, pointToPointDistanceSqr } from '../geometry-functions';\r\nexport function lineToResultsClickHandler(onClick) {\r\n    return function (x, y, size, results, e) {\r\n        let closestResult = results[0];\r\n        let minDistanceSqr = Infinity;\r\n        const closestPoint = { x: 0, y: 0 };\r\n        const point = { x: 0, y: 0 };\r\n        for (const result of results) {\r\n            closestPointOnLine(point, x, y, result.feature.geometry);\r\n            const distanceSqr = pointToPointDistanceSqr(x, y, point.x, point.y);\r\n            if (distanceSqr < minDistanceSqr) {\r\n                closestResult = result;\r\n                minDistanceSqr = distanceSqr;\r\n                closestPoint.x = point.x;\r\n                closestPoint.y = point.y;\r\n            }\r\n        }\r\n        const clickDistanceSqr = 0.25 * (size * size);\r\n        if (minDistanceSqr <= clickDistanceSqr) {\r\n            onClick(closestResult.feature, e, closestPoint);\r\n        }\r\n    };\r\n}\r\n","import { pointToMultiPointDistanceSqr } from '../geometry-functions';\r\nexport function pointToResultsClickHandler(onClick) {\r\n    return function (x, y, size, results, e) {\r\n        let closestResult = results[0];\r\n        let minDistanceSqr = Infinity;\r\n        for (const result of results) {\r\n            const distanceSqr = pointToMultiPointDistanceSqr(x, y, result.feature.geometry);\r\n            if (distanceSqr < minDistanceSqr) {\r\n                closestResult = result;\r\n                minDistanceSqr = distanceSqr;\r\n            }\r\n        }\r\n        const clickDistanceSqr = 0.25 * (size * size);\r\n        if (minDistanceSqr <= clickDistanceSqr) {\r\n            onClick(closestResult.feature, e);\r\n        }\r\n    };\r\n}\r\n","import { isPointInPolygon } from '../geometry-functions';\r\nexport function polygonToResultsClickHandler(onClick) {\r\n    return function (x, y, size, results, e) {\r\n        let closestResult = null;\r\n        let closestIndex = -1;\r\n        for (const result of results) {\r\n            if (result.index > closestIndex && isPointInPolygon(x, y, result.feature.geometry)) {\r\n                closestResult = result;\r\n                closestIndex = result.index;\r\n            }\r\n        }\r\n        if (closestResult != null) {\r\n            onClick(closestResult.feature, e);\r\n        }\r\n    };\r\n}\r\n","export function transformX(lng) {\r\n    return (180 + lng) / 360;\r\n}\r\nexport function transformY(lat) {\r\n    return (180 - (180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360)))) / 360;\r\n}\r\nexport function pointToPointDistanceSqr(x1, y1, x2, y2) {\r\n    return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\r\n}\r\nexport function pointToMultiPointDistanceSqr(x, y, point) {\r\n    if (point.type == 'Point') {\r\n        const coords = point.coordinates;\r\n        return pointToPointDistanceSqr(x, y, coords[0], coords[1]);\r\n    }\r\n    else {\r\n        let minDistanceSqr = Infinity;\r\n        for (const coords of point.coordinates) {\r\n            const distanceSqr = pointToPointDistanceSqr(x, y, coords[0], coords[1]);\r\n            if (distanceSqr < minDistanceSqr) {\r\n                minDistanceSqr = distanceSqr;\r\n            }\r\n        }\r\n        return minDistanceSqr;\r\n    }\r\n}\r\nconst tempPoint = { x: 0, y: 0 };\r\nexport function closestPointOnLine(output, x, y, line) {\r\n    if (line.type === 'LineString') {\r\n        closestPointOnSingleLine(output, x, y, line.coordinates);\r\n    }\r\n    else {\r\n        let minDistanceSqr = Infinity;\r\n        let closestX = 0;\r\n        let closestY = 0;\r\n        for (const coords of line.coordinates) {\r\n            const point = tempPoint;\r\n            closestPointOnSingleLine(point, x, y, coords);\r\n            const distanceSqr = pointToPointDistanceSqr(x, y, point.x, point.y);\r\n            if (distanceSqr < minDistanceSqr) {\r\n                minDistanceSqr = distanceSqr;\r\n                closestX = point.x;\r\n                closestY = point.y;\r\n            }\r\n        }\r\n        output.x = closestX;\r\n        output.y = closestY;\r\n    }\r\n}\r\nfunction closestPointOnSingleLine(output, x, y, coordinates) {\r\n    let minDistanceSqr = Infinity;\r\n    let closestX = x;\r\n    let closestY = y;\r\n    for (let i = 0; i < coordinates.length - 1; i++) {\r\n        const [x1, y1] = coordinates[i];\r\n        const [x2, y2] = coordinates[i + 1];\r\n        const segmentLengthSqr = pointToPointDistanceSqr(x1, y1, x2, y2);\r\n        let projectionX = x1;\r\n        let projectionY = y1;\r\n        if (segmentLengthSqr > 0) {\r\n            const projectionFactor = ((x - x1) * (x2 - x1) + (y - y1) * (y2 - y1)) / segmentLengthSqr;\r\n            const projectionFactorClamped = Math.max(0, Math.min(1, projectionFactor));\r\n            projectionX = x1 + projectionFactorClamped * (x2 - x1);\r\n            projectionY = y1 + projectionFactorClamped * (y2 - y1);\r\n        }\r\n        const distanceSqr = pointToPointDistanceSqr(x, y, projectionX, projectionY);\r\n        if (distanceSqr < minDistanceSqr) {\r\n            minDistanceSqr = distanceSqr;\r\n            closestX = projectionX;\r\n            closestY = projectionY;\r\n        }\r\n    }\r\n    output.x = closestX;\r\n    output.y = closestY;\r\n}\r\nexport function isPointInPolygon(x, y, polygon) {\r\n    if (polygon.type == 'Polygon') {\r\n        return isPointInSinglePolygon(x, y, polygon.coordinates);\r\n    }\r\n    else {\r\n        for (const coords of polygon.coordinates) {\r\n            if (isPointInSinglePolygon(x, y, coords)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\nfunction isPointInSinglePolygon(x, y, coordinates) {\r\n    if (coordinates.length === 0 || !isPointInPolygonNoHoles(x, y, coordinates[0])) {\r\n        return false;\r\n    }\r\n    for (let i = 1; i < coordinates.length; i++) {\r\n        const coords = coordinates[i];\r\n        if (isPointInPolygonNoHoles(x, y, coords)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction isPointInPolygonNoHoles(x, y, coords) {\r\n    let isInside = false;\r\n    for (let i = 0, j = coords.length - 1; i < coords.length; j = i++) {\r\n        const xi = coords[i][0], yi = coords[i][1];\r\n        const xj = coords[j][0], yj = coords[j][1];\r\n        const doseIntersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\r\n        if (doseIntersect) {\r\n            isInside = !isInside;\r\n        }\r\n    }\r\n    return isInside;\r\n}\r\nexport function cosOfPointsAngle(x1, y1, x2, y2, x3, y3) {\r\n    return cosOfAngleBetweenVectors(x2 - x1, y2 - y1, x2 - x3, y2 - y3);\r\n}\r\nexport function cosOfAngleBetweenVectors(x1, y1, x2, y2) {\r\n    const dot = x1 * x2 + y1 * y2;\r\n    const length1 = Math.sqrt(x1 * x1 + y1 * y1);\r\n    const length2 = Math.sqrt(x2 * x2 + y2 * y2);\r\n    return dot / (length1 * length2);\r\n}\r\nexport function findViewBounds(output, map) {\r\n    const bounds = map.getBounds();\r\n    output.minX = transformX(bounds.getWest());\r\n    output.minY = transformY(bounds.getNorth());\r\n    output.maxX = transformX(bounds.getEast());\r\n    output.maxY = transformY(bounds.getSouth());\r\n}\r\nexport function findFeatureCollectionBounds(output, featureCollection) {\r\n    output.minX = Infinity;\r\n    output.minY = Infinity;\r\n    output.maxX = -Infinity;\r\n    output.maxY = -Infinity;\r\n    for (const feature of featureCollection.features) {\r\n        findGeometryBounds(output, feature.geometry);\r\n    }\r\n}\r\nexport function findFeaturesBounds(output, features) {\r\n    output.minX = Infinity;\r\n    output.minY = Infinity;\r\n    output.maxX = -Infinity;\r\n    output.maxY = -Infinity;\r\n    for (const feature of features) {\r\n        findGeometryBounds(output, feature.geometry);\r\n    }\r\n}\r\nexport function findFeatureBounds(output, feature) {\r\n    output.minX = Infinity;\r\n    output.minY = Infinity;\r\n    output.maxX = -Infinity;\r\n    output.maxY = -Infinity;\r\n    findGeometryBounds(output, feature.geometry);\r\n}\r\nfunction findGeometryBounds(output, geometry) {\r\n    if (geometry.type === 'GeometryCollection') {\r\n        for (const g of geometry.geometries) {\r\n            findGeometryBounds(output, g);\r\n        }\r\n    }\r\n    else {\r\n        findCoordinatesBounds(output, geometry.coordinates);\r\n    }\r\n}\r\nfunction findCoordinatesBounds(output, coords) {\r\n    for (let i = 0; i < coords.length; i++) {\r\n        const c = coords[i];\r\n        if (typeof c === 'number') {\r\n            if (i === 0) {\r\n                if (c < output.minX)\r\n                    output.minX = c;\r\n                if (c > output.maxX)\r\n                    output.maxX = c;\r\n            }\r\n            else if (i === 1) {\r\n                if (c < output.minY)\r\n                    output.minY = c;\r\n                if (c > output.maxY)\r\n                    output.maxY = c;\r\n            }\r\n        }\r\n        else {\r\n            findCoordinatesBounds(output, c);\r\n        }\r\n    }\r\n}\r\nexport function packFeature(feature, index) {\r\n    const packed = {\r\n        feature: feature,\r\n        index: index,\r\n        minX: Infinity,\r\n        minY: Infinity,\r\n        maxX: -Infinity,\r\n        maxY: -Infinity\r\n    };\r\n    findFeatureBounds(packed, feature);\r\n    return packed;\r\n}\r\n","import vertexSource from './default.vert';\r\nimport fragmentSource from './default.frag';\r\nexport class DefaultShader {\r\n    constructor() {\r\n        this.vertexSource = vertexSource;\r\n        this.fragmentSource = fragmentSource;\r\n    }\r\n    configureAttributes(gl, program) {\r\n        const position = gl.getAttribLocation(program, 'a_position');\r\n        const color = gl.getAttribLocation(program, 'a_color');\r\n        const vertexSize = 6 * Float32Array.BYTES_PER_ELEMENT;\r\n        gl.vertexAttribPointer(position, 2, gl.FLOAT, false, vertexSize, 0);\r\n        gl.vertexAttribPointer(color, 4, gl.FLOAT, false, vertexSize, 2 * Float32Array.BYTES_PER_ELEMENT);\r\n        gl.enableVertexAttribArray(position);\r\n        gl.enableVertexAttribArray(color);\r\n        return () => {\r\n            gl.disableVertexAttribArray(position);\r\n            gl.disableVertexAttribArray(color);\r\n        };\r\n    }\r\n    getArrayBufferElementsPerVertex() {\r\n        return 6;\r\n    }\r\n    setUniforms(gl, program, matrix) {\r\n        gl.uniformMatrix4fv(gl.getUniformLocation(program, 'u_matrix'), false, matrix);\r\n    }\r\n}\r\n","module.exports = \"precision mediump float;\\r\\n\\r\\nvarying vec4 v_color;\\r\\n\\r\\nvoid main() {\\r\\n    gl_FragColor = v_color;\\r\\n}\\r\\n\"","module.exports = \"precision mediump float;\\r\\n\\r\\nuniform mat4 u_matrix;\\r\\n\\r\\nattribute vec2 a_position;\\r\\nattribute vec4 a_color;\\r\\n\\r\\nvarying vec4 v_color;\\r\\n\\r\\nvoid main() {\\r\\n    v_color = a_color;\\r\\n    gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\\r\\n}\\r\\n\"","import vertexSource from './fancy-line.vert';\r\nimport fragmentSource from './fancy-line.frag';\r\nexport class FancyLineShader {\r\n    constructor(interpolation = 1.8) {\r\n        this.interpolation = interpolation;\r\n        this.vertexSource = vertexSource;\r\n        this.fragmentSource = fragmentSource;\r\n    }\r\n    configureAttributes(gl, program) {\r\n        const previousPosition = gl.getAttribLocation(program, 'a_previousPosition');\r\n        const currentPosition = gl.getAttribLocation(program, 'a_currentPosition');\r\n        const nextPosition = gl.getAttribLocation(program, 'a_nextPosition');\r\n        const size = gl.getAttribLocation(program, 'a_size');\r\n        const color = gl.getAttribLocation(program, 'a_color');\r\n        const outlineSize = gl.getAttribLocation(program, 'a_outlineSize');\r\n        const outlineColor = gl.getAttribLocation(program, 'a_outlineColor');\r\n        const vertexSize = 16 * Float32Array.BYTES_PER_ELEMENT;\r\n        gl.vertexAttribPointer(previousPosition, 2, gl.FLOAT, false, vertexSize, 0);\r\n        gl.vertexAttribPointer(currentPosition, 2, gl.FLOAT, false, vertexSize, 2 * Float32Array.BYTES_PER_ELEMENT);\r\n        gl.vertexAttribPointer(nextPosition, 2, gl.FLOAT, false, vertexSize, 4 * Float32Array.BYTES_PER_ELEMENT);\r\n        gl.vertexAttribPointer(size, 1, gl.FLOAT, false, vertexSize, 6 * Float32Array.BYTES_PER_ELEMENT);\r\n        gl.vertexAttribPointer(outlineSize, 1, gl.FLOAT, false, vertexSize, 7 * Float32Array.BYTES_PER_ELEMENT);\r\n        gl.vertexAttribPointer(color, 4, gl.FLOAT, false, vertexSize, 8 * Float32Array.BYTES_PER_ELEMENT);\r\n        gl.vertexAttribPointer(outlineColor, 4, gl.FLOAT, false, vertexSize, 12 * Float32Array.BYTES_PER_ELEMENT);\r\n        gl.enableVertexAttribArray(previousPosition);\r\n        gl.enableVertexAttribArray(currentPosition);\r\n        gl.enableVertexAttribArray(nextPosition);\r\n        gl.enableVertexAttribArray(size);\r\n        gl.enableVertexAttribArray(color);\r\n        gl.enableVertexAttribArray(outlineSize);\r\n        gl.enableVertexAttribArray(outlineColor);\r\n        return () => {\r\n            gl.disableVertexAttribArray(previousPosition);\r\n            gl.disableVertexAttribArray(currentPosition);\r\n            gl.disableVertexAttribArray(nextPosition);\r\n            gl.disableVertexAttribArray(size);\r\n            gl.disableVertexAttribArray(color);\r\n            gl.disableVertexAttribArray(outlineSize);\r\n            gl.disableVertexAttribArray(outlineColor);\r\n        };\r\n    }\r\n    setUniforms(gl, program, matrix) {\r\n        const viewport = gl.getParameter(gl.VIEWPORT);\r\n        gl.uniformMatrix4fv(gl.getUniformLocation(program, 'u_matrix'), false, matrix);\r\n        gl.uniform2f(gl.getUniformLocation(program, 'u_viewPortSize'), viewport[2], viewport[3]);\r\n        gl.uniform1f(gl.getUniformLocation(program, 'u_interpolation'), this.interpolation);\r\n    }\r\n    getArrayBufferElementsPerVertex() {\r\n        return 16;\r\n    }\r\n    getPrimitiveType(gl) {\r\n        return gl.TRIANGLES;\r\n    }\r\n}\r\n","module.exports = \"precision mediump float;\\r\\n\\r\\nuniform float u_interpolation;\\r\\n\\r\\nvarying float v_halfSize;\\r\\nvarying float v_outlineSize;\\r\\nvarying vec4 v_color;\\r\\nvarying vec4 v_outlineColor;\\r\\nvarying float v_distance;\\r\\n\\r\\nvoid main() {\\r\\n    float dist = abs(v_distance);\\r\\n    bool branch = dist < v_halfSize;\\r\\n    float x = branch ? dist - v_halfSize : dist - v_halfSize - v_outlineSize;\\r\\n    vec4 color1 = branch ? v_color : v_outlineColor;\\r\\n    vec4 color2 = branch ? v_outlineColor : vec4(v_outlineColor.rgb, 0.0);\\r\\n    float m = smoothstep(-u_interpolation, 0.0, x);\\r\\n    gl_FragColor = mix(color1, color2, m);\\r\\n}\\r\\n\"","module.exports = \"precision mediump float;\\r\\n\\r\\nuniform mat4 u_matrix;\\r\\nuniform vec2 u_viewPortSize;\\r\\n\\r\\nattribute vec2 a_previousPosition;\\r\\nattribute vec2 a_currentPosition;\\r\\nattribute vec2 a_nextPosition;\\r\\nattribute float a_size;\\r\\nattribute float a_outlineSize;\\r\\nattribute vec4 a_color;\\r\\nattribute vec4 a_outlineColor;\\r\\n\\r\\nvarying float v_halfSize;\\r\\nvarying float v_outlineSize;\\r\\nvarying vec4 v_color;\\r\\nvarying vec4 v_outlineColor;\\r\\nvarying float v_distance;\\r\\n\\r\\nvoid main() {\\r\\n    v_halfSize = abs(0.5 * a_size);\\r\\n    v_outlineSize = abs(a_outlineSize);\\r\\n    v_color = a_color;\\r\\n    v_outlineColor = a_outlineColor;\\r\\n    v_distance = 0.5 * a_size + a_outlineSize;\\r\\n\\r\\n    vec4 previousProjected = u_matrix * vec4(a_previousPosition, 0.0, 1.0);\\r\\n    vec4 currentProjected = u_matrix * vec4(a_currentPosition, 0.0, 1.0);\\r\\n    vec4 nextProjected = u_matrix * vec4(a_nextPosition, 0.0, 1.0);\\r\\n\\r\\n    vec2 previousScreen = previousProjected.xy / previousProjected.w * u_viewPortSize;\\r\\n    vec2 currentScreen = currentProjected.xy / currentProjected.w * u_viewPortSize;\\r\\n    vec2 nextScreen = nextProjected.xy / nextProjected.w * u_viewPortSize;\\r\\n\\r\\n    vec2 dirA = normalize(currentScreen - previousScreen);\\r\\n    vec2 dirB = normalize(nextScreen - currentScreen);\\r\\n    vec2 tangent = normalize(dirA + dirB);\\r\\n    vec2 perp = vec2(-dirA.y, dirA.x);\\r\\n\\r\\n    vec2 normal = vec2(-tangent.y, tangent.x);\\r\\n    vec2 offset = (2.0 * v_distance / max(dot(normal, perp), 0.1) * normal) / u_viewPortSize;\\r\\n\\r\\n    gl_Position = vec4(currentProjected.xy / max(currentProjected.w, 0.0001) + offset, 0.0, 1.0);\\r\\n}\\r\\n\"","import { DefaultShader } from '../default/default-shader';\r\nexport class SimpleLineShader extends DefaultShader {\r\n    getPrimitiveType(gl) {\r\n        return gl.LINES;\r\n    }\r\n}\r\n","import vertexSource from './fancy-point.vert';\r\nimport fragmentSource from './fancy-point.frag';\r\nexport class FancyPointShader {\r\n    constructor(interpolation = 1.8) {\r\n        this.interpolation = interpolation;\r\n        this.vertexSource = vertexSource;\r\n        this.fragmentSource = fragmentSource;\r\n    }\r\n    configureAttributes(gl, program) {\r\n        const position = gl.getAttribLocation(program, 'a_position');\r\n        const size = gl.getAttribLocation(program, 'a_size');\r\n        const color = gl.getAttribLocation(program, 'a_color');\r\n        const outlineSize = gl.getAttribLocation(program, 'a_outlineSize');\r\n        const outlineColor = gl.getAttribLocation(program, 'a_outlineColor');\r\n        const vertexSize = 12 * Float32Array.BYTES_PER_ELEMENT;\r\n        gl.vertexAttribPointer(position, 2, gl.FLOAT, false, vertexSize, 0);\r\n        gl.vertexAttribPointer(size, 1, gl.FLOAT, false, vertexSize, 2 * Float32Array.BYTES_PER_ELEMENT);\r\n        gl.vertexAttribPointer(color, 4, gl.FLOAT, false, vertexSize, 3 * Float32Array.BYTES_PER_ELEMENT);\r\n        gl.vertexAttribPointer(outlineSize, 1, gl.FLOAT, false, vertexSize, 7 * Float32Array.BYTES_PER_ELEMENT);\r\n        gl.vertexAttribPointer(outlineColor, 4, gl.FLOAT, false, vertexSize, 8 * Float32Array.BYTES_PER_ELEMENT);\r\n        gl.enableVertexAttribArray(position);\r\n        gl.enableVertexAttribArray(size);\r\n        gl.enableVertexAttribArray(color);\r\n        gl.enableVertexAttribArray(outlineSize);\r\n        gl.enableVertexAttribArray(outlineColor);\r\n        return () => {\r\n            gl.disableVertexAttribArray(position);\r\n            gl.disableVertexAttribArray(size);\r\n            gl.disableVertexAttribArray(color);\r\n            gl.disableVertexAttribArray(outlineSize);\r\n            gl.disableVertexAttribArray(outlineColor);\r\n        };\r\n    }\r\n    setUniforms(gl, program, matrix) {\r\n        gl.uniformMatrix4fv(gl.getUniformLocation(program, 'u_matrix'), false, matrix);\r\n        gl.uniform1f(gl.getUniformLocation(program, 'u_interpolation'), this.interpolation);\r\n    }\r\n    getArrayBufferElementsPerVertex() {\r\n        return 12;\r\n    }\r\n    getPrimitiveType(gl) {\r\n        return gl.POINTS;\r\n    }\r\n}\r\n","module.exports = \"precision mediump float;\\r\\n\\r\\nuniform float u_interpolation;\\r\\n\\r\\nvarying float v_size;\\r\\nvarying vec4 v_color;\\r\\nvarying float v_outlineSize;\\r\\nvarying vec4 v_outlineColor;\\r\\nvarying float v_pointSize;\\r\\nvarying float v_halfSize;\\r\\n\\r\\nvoid main() {\\r\\n    float dist = v_pointSize * distance(gl_PointCoord, vec2(0.5, 0.5));\\r\\n    bool branch = dist < v_halfSize;\\r\\n    float x = branch ? dist - v_halfSize : dist - v_halfSize - v_outlineSize;\\r\\n    vec4 color1 = branch ? v_color : v_outlineColor;\\r\\n    vec4 color2 = branch ? v_outlineColor : vec4(v_outlineColor.rgb, 0.0);\\r\\n    float m = smoothstep(-u_interpolation, 0.0, x);\\r\\n    gl_FragColor = mix(color1, color2, m);\\r\\n}\\r\\n\"","module.exports = \"precision mediump float;\\r\\n\\r\\nuniform mat4 u_matrix;\\r\\n\\r\\nattribute vec2 a_position;\\r\\nattribute float a_size;\\r\\nattribute vec4 a_color;\\r\\nattribute float a_outlineSize;\\r\\nattribute vec4 a_outlineColor;\\r\\n\\r\\nvarying float v_size;\\r\\nvarying vec4 v_color;\\r\\nvarying float v_outlineSize;\\r\\nvarying vec4 v_outlineColor;\\r\\nvarying float v_pointSize;\\r\\nvarying float v_halfSize;\\r\\n\\r\\nvoid main() {\\r\\n    v_size = a_size;\\r\\n    v_color = a_color;\\r\\n    v_outlineSize = a_outlineSize;\\r\\n    v_outlineColor = a_outlineColor;\\r\\n    v_pointSize = a_size + 2.0*a_outlineSize;\\r\\n    v_halfSize = 0.5*v_size;\\r\\n\\r\\n    gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\\r\\n    gl_PointSize = v_pointSize;\\r\\n}\\r\\n\"","import vertexSource from './simple-point.vert';\r\nimport fragmentSource from './simple-point.frag';\r\nexport class SimplePointShader {\r\n    constructor(interpolation = 1.8) {\r\n        this.interpolation = interpolation;\r\n        this.vertexSource = vertexSource;\r\n        this.fragmentSource = fragmentSource;\r\n    }\r\n    configureAttributes(gl, program) {\r\n        const position = gl.getAttribLocation(program, 'a_position');\r\n        const size = gl.getAttribLocation(program, 'a_size');\r\n        const color = gl.getAttribLocation(program, 'a_color');\r\n        const vertexSize = 7 * Float32Array.BYTES_PER_ELEMENT;\r\n        gl.vertexAttribPointer(position, 2, gl.FLOAT, false, vertexSize, 0);\r\n        gl.vertexAttribPointer(size, 1, gl.FLOAT, false, vertexSize, 2 * Float32Array.BYTES_PER_ELEMENT);\r\n        gl.vertexAttribPointer(color, 4, gl.FLOAT, false, vertexSize, 3 * Float32Array.BYTES_PER_ELEMENT);\r\n        gl.enableVertexAttribArray(position);\r\n        gl.enableVertexAttribArray(size);\r\n        gl.enableVertexAttribArray(color);\r\n        return () => {\r\n            gl.disableVertexAttribArray(position);\r\n            gl.disableVertexAttribArray(size);\r\n            gl.disableVertexAttribArray(color);\r\n        };\r\n    }\r\n    setUniforms(gl, program, matrix) {\r\n        gl.uniformMatrix4fv(gl.getUniformLocation(program, 'u_matrix'), false, matrix);\r\n        gl.uniform1f(gl.getUniformLocation(program, 'u_interpolation'), this.interpolation);\r\n    }\r\n    getArrayBufferElementsPerVertex() {\r\n        return 7;\r\n    }\r\n    getPrimitiveType(gl) {\r\n        return gl.POINTS;\r\n    }\r\n}\r\n","module.exports = \"precision mediump float;\\r\\n\\r\\nuniform float u_interpolation;\\r\\n\\r\\nvarying float v_size;\\r\\nvarying vec4 v_color;\\r\\nvarying float v_halfSize;\\r\\n\\r\\nvoid main() {\\r\\n    float dist = v_size * distance(gl_PointCoord, vec2(0.5, 0.5));\\r\\n    float x = dist - v_halfSize;\\r\\n    float m = smoothstep(-u_interpolation, 0.0, x);\\r\\n    gl_FragColor = mix(v_color, vec4(v_color.rgb, 0.0), m);\\r\\n}\\r\\n\"","module.exports = \"precision mediump float;\\r\\n\\r\\nuniform mat4 u_matrix;\\r\\n\\r\\nattribute vec2 a_position;\\r\\nattribute float a_size;\\r\\nattribute vec4 a_color;\\r\\n\\r\\nvarying float v_size;\\r\\nvarying vec4 v_color;\\r\\nvarying float v_halfSize;\\r\\n\\r\\nvoid main() {\\r\\n    v_size = a_size;\\r\\n    v_color = a_color;\\r\\n    v_halfSize = 0.5*a_size;\\r\\n\\r\\n    gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\\r\\n    gl_PointSize = a_size;\\r\\n}\\r\\n\"","import vertexSource from './fancy-polygon.vert';\r\nimport fragmentSource from './fancy-polygon.frag';\r\nexport class FancyPolygonShader {\r\n    constructor(interpolation = 1.8) {\r\n        this.interpolation = interpolation;\r\n        this.vertexSource = vertexSource;\r\n        this.fragmentSource = fragmentSource;\r\n    }\r\n    configureAttributes(gl, program) {\r\n        const previousPosition = gl.getAttribLocation(program, 'a_previousPosition');\r\n        const currentPosition = gl.getAttribLocation(program, 'a_currentPosition');\r\n        const nextPosition = gl.getAttribLocation(program, 'a_nextPosition');\r\n        const outlineSize = gl.getAttribLocation(program, 'a_outlineSize');\r\n        const offset = gl.getAttribLocation(program, 'a_offset');\r\n        const color = gl.getAttribLocation(program, 'a_color');\r\n        const outlineColor = gl.getAttribLocation(program, 'a_outlineColor');\r\n        const vertexSize = 16 * Float32Array.BYTES_PER_ELEMENT;\r\n        gl.vertexAttribPointer(previousPosition, 2, gl.FLOAT, false, vertexSize, 0);\r\n        gl.vertexAttribPointer(currentPosition, 2, gl.FLOAT, false, vertexSize, 2 * Float32Array.BYTES_PER_ELEMENT);\r\n        gl.vertexAttribPointer(nextPosition, 2, gl.FLOAT, false, vertexSize, 4 * Float32Array.BYTES_PER_ELEMENT);\r\n        gl.vertexAttribPointer(outlineSize, 1, gl.FLOAT, false, vertexSize, 6 * Float32Array.BYTES_PER_ELEMENT);\r\n        gl.vertexAttribPointer(offset, 1, gl.FLOAT, false, vertexSize, 7 * Float32Array.BYTES_PER_ELEMENT);\r\n        gl.vertexAttribPointer(color, 4, gl.FLOAT, false, vertexSize, 8 * Float32Array.BYTES_PER_ELEMENT);\r\n        gl.vertexAttribPointer(outlineColor, 4, gl.FLOAT, false, vertexSize, 12 * Float32Array.BYTES_PER_ELEMENT);\r\n        gl.enableVertexAttribArray(previousPosition);\r\n        gl.enableVertexAttribArray(currentPosition);\r\n        gl.enableVertexAttribArray(nextPosition);\r\n        gl.enableVertexAttribArray(outlineSize);\r\n        gl.enableVertexAttribArray(offset);\r\n        gl.enableVertexAttribArray(color);\r\n        gl.enableVertexAttribArray(outlineColor);\r\n        return () => {\r\n            gl.disableVertexAttribArray(previousPosition);\r\n            gl.disableVertexAttribArray(currentPosition);\r\n            gl.disableVertexAttribArray(nextPosition);\r\n            gl.disableVertexAttribArray(outlineSize);\r\n            gl.disableVertexAttribArray(offset);\r\n            gl.disableVertexAttribArray(color);\r\n            gl.disableVertexAttribArray(outlineColor);\r\n        };\r\n    }\r\n    setUniforms(gl, program, matrix) {\r\n        const viewport = gl.getParameter(gl.VIEWPORT);\r\n        gl.uniformMatrix4fv(gl.getUniformLocation(program, 'u_matrix'), false, matrix);\r\n        gl.uniform2f(gl.getUniformLocation(program, 'u_viewPortSize'), viewport[2], viewport[3]);\r\n        gl.uniform1f(gl.getUniformLocation(program, 'u_interpolation'), this.interpolation);\r\n    }\r\n    getArrayBufferElementsPerVertex() {\r\n        return 16;\r\n    }\r\n    getPrimitiveType(gl) {\r\n        return gl.TRIANGLES;\r\n    }\r\n}\r\n","module.exports = \"precision mediump float;\\r\\n\\r\\nuniform float u_interpolation;\\r\\n\\r\\nvarying vec4 v_color;\\r\\nvarying vec4 v_outlineColor;\\r\\nvarying float v_size;\\r\\nvarying float v_distance;\\r\\n\\r\\nvoid main() {\\r\\n    bool branch = v_distance < u_interpolation;\\r\\n    float x = branch ? v_distance : v_size - v_distance;\\r\\n    vec4 color1 = branch ? v_color : vec4(v_outlineColor.rgb, 0.0);\\r\\n    vec4 color2 = branch ? v_outlineColor : v_outlineColor;\\r\\n    float m = smoothstep(0.0, u_interpolation, x);\\r\\n    gl_FragColor = mix(color1, color2, m);\\r\\n}\\r\\n\"","module.exports = \"precision mediump float;\\r\\n\\r\\nuniform mat4 u_matrix;\\r\\nuniform vec2 u_viewPortSize;\\r\\nuniform float u_interpolation;\\r\\n\\r\\nattribute vec2 a_previousPosition;\\r\\nattribute vec2 a_currentPosition;\\r\\nattribute vec2 a_nextPosition;\\r\\nattribute float a_outlineSize;\\r\\nattribute float a_offset;\\r\\nattribute vec4 a_color;\\r\\nattribute vec4 a_outlineColor;\\r\\n\\r\\nvarying vec4 v_color;\\r\\nvarying vec4 v_outlineColor;\\r\\nvarying float v_size;\\r\\nvarying float v_distance;\\r\\n\\r\\nvoid main() {\\r\\n    v_color = a_color;\\r\\n    v_outlineColor = a_outlineColor;\\r\\n    v_size = a_outlineSize + u_interpolation;\\r\\n    v_distance = a_offset * v_size;\\r\\n\\r\\n    vec4 previousProjected = u_matrix * vec4(a_previousPosition, 0.0, 1.0);\\r\\n    vec4 currentProjected = u_matrix * vec4(a_currentPosition, 0.0, 1.0);\\r\\n    vec4 nextProjected = u_matrix * vec4(a_nextPosition, 0.0, 1.0);\\r\\n\\r\\n    vec2 previousScreen = previousProjected.xy / previousProjected.w * u_viewPortSize;\\r\\n    vec2 currentScreen = currentProjected.xy / currentProjected.w * u_viewPortSize;\\r\\n    vec2 nextScreen = nextProjected.xy / nextProjected.w * u_viewPortSize;\\r\\n\\r\\n    vec2 dirA = normalize(currentScreen - previousScreen);\\r\\n    vec2 dirB = normalize(nextScreen - currentScreen);\\r\\n    vec2 tangent = normalize(dirA + dirB);\\r\\n    vec2 perp = vec2(-dirA.y, dirA.x);\\r\\n\\r\\n    vec2 normal = vec2(-tangent.y, tangent.x);\\r\\n    vec2 offset = (2.0 * v_distance / max(dot(normal, perp), 0.1) * normal) / u_viewPortSize;\\r\\n\\r\\n    gl_Position = vec4(currentProjected.xy / max(currentProjected.w, 0.0001) - offset, 0.0, 1.0);\\r\\n}\\r\\n\"","import { DefaultShader } from '../default/default-shader';\r\nexport class SimplePolygonShader extends DefaultShader {\r\n    getPrimitiveType(gl) {\r\n        return gl.TRIANGLES;\r\n    }\r\n}\r\n","export function createShaderProgram(gl, vertexSource, fragmentSource) {\r\n    const vertexShader = gl.createShader(gl.VERTEX_SHADER);\r\n    if (vertexShader == null) {\r\n        throw Error('Vertex shader is NULL.');\r\n    }\r\n    gl.shaderSource(vertexShader, vertexSource);\r\n    gl.compileShader(vertexShader);\r\n    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\r\n        throw Error('ERROR compiling vertex shader! ' + gl.getShaderInfoLog(vertexShader));\r\n    }\r\n    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\r\n    if (fragmentShader == null) {\r\n        throw Error('Fragment shader is NULL.');\r\n    }\r\n    gl.shaderSource(fragmentShader, fragmentSource);\r\n    gl.compileShader(fragmentShader);\r\n    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\r\n        throw Error('ERROR compiling fragment shader! ' + gl.getShaderInfoLog(fragmentShader));\r\n    }\r\n    const program = gl.createProgram();\r\n    if (program == null) {\r\n        throw Error('Program is NULL.');\r\n    }\r\n    gl.attachShader(program, vertexShader);\r\n    gl.attachShader(program, fragmentShader);\r\n    gl.linkProgram(program);\r\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\r\n        throw Error('ERROR linking program! ' + gl.getProgramInfoLog(program));\r\n    }\r\n    gl.validateProgram(program);\r\n    if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {\r\n        throw Error('ERROR validating program! ' + gl.getProgramInfoLog(program));\r\n    }\r\n    return program;\r\n}\r\n","module.exports = \"precision mediump float;\\r\\n\\r\\nuniform sampler2D u_sampler;\\r\\n\\r\\nvarying vec2 v_textureCoordinate;\\r\\n\\r\\nvoid main() {\\r\\n    gl_FragColor = texture2D(u_sampler, v_textureCoordinate);\\r\\n}\\r\\n\"","import { createShaderProgram } from '../shader';\r\nimport vertexSource from './texture-drawer.vert';\r\nimport fragmentSource from './texture-drawer.frag';\r\nexport class TextureDrawer {\r\n    constructor() {\r\n        this.program = null;\r\n        this.vertexBuffer = null;\r\n    }\r\n    initialise(gl) {\r\n        this.program = createShaderProgram(gl, vertexSource, fragmentSource);\r\n        this.vertexBuffer = gl.createBuffer();\r\n    }\r\n    dispose(gl) {\r\n        gl.deleteBuffer(this.vertexBuffer);\r\n        gl.deleteProgram(this.program);\r\n    }\r\n    draw(gl, texture, matrix, x, y, w, h) {\r\n        if (this.program == null || this.vertexBuffer == null) {\r\n            throw Error('TextureDrawer can not draw before it is initialised.');\r\n        }\r\n        gl.enable(gl.BLEND);\r\n        gl.blendEquation(gl.FUNC_ADD);\r\n        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\r\n        const x1 = x, x2 = x + w, y1 = y, y2 = y + h;\r\n        const bufferArray = new Float32Array([\r\n            x1, y1, 0, 1,\r\n            x2, y1, 1, 1,\r\n            x2, y2, 1, 0,\r\n            x1, y1, 0, 1,\r\n            x1, y2, 0, 0,\r\n            x2, y2, 1, 0\r\n        ]);\r\n        gl.bindTexture(gl.TEXTURE_2D, texture);\r\n        gl.useProgram(this.program);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\r\n        const cleanUpAttributes = configureAttributes(gl, this.program);\r\n        gl.bufferData(gl.ARRAY_BUFFER, bufferArray, gl.STATIC_DRAW);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\r\n        setUniforms(gl, this.program, matrix);\r\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\r\n        gl.bindTexture(gl.TEXTURE_2D, null);\r\n        cleanUpAttributes();\r\n    }\r\n}\r\nfunction configureAttributes(gl, program) {\r\n    const position = gl.getAttribLocation(program, 'a_position');\r\n    const textureCoordinate = gl.getAttribLocation(program, 'a_textureCoordinate');\r\n    const vertexSize = 4 * Float32Array.BYTES_PER_ELEMENT;\r\n    gl.vertexAttribPointer(position, 2, gl.FLOAT, false, vertexSize, 0);\r\n    gl.vertexAttribPointer(textureCoordinate, 2, gl.FLOAT, false, vertexSize, 2 * Float32Array.BYTES_PER_ELEMENT);\r\n    gl.enableVertexAttribArray(position);\r\n    gl.enableVertexAttribArray(textureCoordinate);\r\n    return () => {\r\n        gl.disableVertexAttribArray(position);\r\n        gl.disableVertexAttribArray(textureCoordinate);\r\n    };\r\n}\r\nfunction setUniforms(gl, program, matrix) {\r\n    gl.uniformMatrix4fv(gl.getUniformLocation(program, 'u_matrix'), false, matrix);\r\n    gl.uniform1i(gl.getUniformLocation(program, 'u_sampler'), 0);\r\n}\r\n","module.exports = \"precision mediump float;\\r\\n\\r\\nuniform mat4 u_matrix;\\r\\nuniform sampler2D u_sampler;\\r\\n\\r\\nattribute vec2 a_position;\\r\\nattribute vec2 a_textureCoordinate;\\r\\n\\r\\nvarying vec2 v_textureCoordinate;\\r\\n\\r\\nvoid main() {\\r\\n    v_textureCoordinate = a_textureCoordinate;\\r\\n    gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\\r\\n}\\r\\n\"","export const defaultPointStyle = {\r\n    size: 10,\r\n    color: { r: 0, g: 0, b: 1 },\r\n    opacity: 0.8,\r\n    outlineSize: 0,\r\n    outlineColor: { r: 0, g: 0, b: 0 },\r\n    outlineOpacity: 0.8\r\n};\r\nexport const defaultLineStyle = {\r\n    size: 5,\r\n    color: { r: 0, g: 0, b: 1 },\r\n    opacity: 0.8,\r\n    outlineSize: 0,\r\n    outlineColor: { r: 0, g: 0, b: 0 },\r\n    outlineOpacity: 0.8\r\n};\r\nexport const defaultPolygonStyle = {\r\n    color: { r: 0, g: 0, b: 1 },\r\n    opacity: 0.5,\r\n    outlineSize: 0,\r\n    outlineColor: { r: 0, g: 0, b: 0 },\r\n    outlineOpacity: 0.8\r\n};\r\nexport function resolveStyle(output, feature, styleOption, defaultStyle) {\r\n    // @ts-ignore\r\n    Object.keys(defaultStyle).forEach(key => output[key] = defaultStyle[key]);\r\n    if (styleOption != null) {\r\n        const partialStyle = typeof styleOption === 'object' ? styleOption : styleOption(feature);\r\n        // @ts-ignore\r\n        Object.keys(partialStyle).forEach(key => output[key] = partialStyle[key]);\r\n    }\r\n}\r\nexport function resolvePointStyle(output, feature, styleOption) {\r\n    resolveStyle(output, feature, styleOption, defaultPointStyle);\r\n    if (output.outlineSize <= 0) {\r\n        output.outlineColor = output.color;\r\n        output.outlineOpacity = output.opacity;\r\n    }\r\n}\r\nexport function resolveLineStyle(output, feature, styleOption) {\r\n    resolveStyle(output, feature, styleOption, defaultLineStyle);\r\n    if (output.outlineSize <= 0) {\r\n        output.outlineColor = output.color;\r\n        output.outlineOpacity = output.opacity;\r\n    }\r\n}\r\nexport function resolvePolygonStyle(output, feature, styleOption) {\r\n    resolveStyle(output, feature, styleOption, defaultPolygonStyle);\r\n    if (output.outlineSize <= 0) {\r\n        output.outlineColor = output.color;\r\n        output.outlineOpacity = output.opacity;\r\n    }\r\n}\r\n","import * as glMatrix from 'gl-matrix';\r\nexport class TileGenerator {\r\n    constructor(renderer) {\r\n        this.renderer = renderer;\r\n        this.frameBuffer = null;\r\n        this.matrix = glMatrix.mat4.create();\r\n    }\r\n    initialise(map, gl) {\r\n        this.frameBuffer = gl.createFramebuffer();\r\n        this.renderer.initialise(map, gl);\r\n    }\r\n    dispose(map, gl) {\r\n        this.renderer.dispose(map, gl);\r\n        gl.deleteFramebuffer(this.frameBuffer);\r\n    }\r\n    generateTile(gl, texture, textureWidth, textureHeight, x, y, zoom) {\r\n        if (this.frameBuffer == null) {\r\n            throw Error('TileGenerator can not generate tiles before it is initialised.');\r\n        }\r\n        const oldFrameBuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);\r\n        const oldViewport = gl.getParameter(gl.VIEWPORT);\r\n        this.setMatrixValue(x, y, zoom);\r\n        this.renderer.prerender(gl, this.matrix);\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);\r\n        gl.viewport(0, 0, textureWidth, textureHeight);\r\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\r\n        gl.clearColor(0, 0, 0, 0);\r\n        gl.clear(gl.COLOR_BUFFER_BIT);\r\n        this.renderer.render(gl, this.matrix);\r\n        gl.viewport(oldViewport[0], oldViewport[1], oldViewport[2], oldViewport[3]);\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, oldFrameBuffer);\r\n        gl.bindTexture(gl.TEXTURE_2D, null);\r\n    }\r\n    setMatrixValue(x, y, zoom) {\r\n        const viewportSize = Math.pow(2, -zoom);\r\n        const viewportX = x * viewportSize;\r\n        const viewportY = y * viewportSize;\r\n        glMatrix.mat4.ortho(this.matrix, viewportX, viewportX + viewportSize, viewportY + viewportSize, viewportY, -1, 1);\r\n    }\r\n}\r\n","import { transformX, transformY } from '../geometry-functions';\r\nexport class TileManager {\r\n    constructor(generator, numberOfTiles, tileWidth, tileHeight) {\r\n        this.generator = generator;\r\n        this.numberOfTiles = numberOfTiles;\r\n        this.tileWidth = tileWidth;\r\n        this.tileHeight = tileHeight;\r\n        this.tiles = null;\r\n    }\r\n    markAllTilesOutdated() {\r\n        if (this.tiles == null) {\r\n            return;\r\n        }\r\n        for (const tile of this.tiles) {\r\n            tile.zoom = -1;\r\n            tile.age = Number.MAX_VALUE / 2;\r\n        }\r\n    }\r\n    markOutdatedTiles(bounds) {\r\n        if (this.tiles == null) {\r\n            return;\r\n        }\r\n        for (const tile of this.tiles) {\r\n            if (isTileInDataBounds(tile.x, tile.y, tile.zoom, bounds)) {\r\n                tile.zoom = -1;\r\n                tile.age = Number.MAX_VALUE / 2;\r\n            }\r\n        }\r\n    }\r\n    initialise(map, gl) {\r\n        this.generator.initialise(map, gl);\r\n        const tiles = [];\r\n        for (let i = 0; i < this.numberOfTiles; i++) {\r\n            const texture = gl.createTexture();\r\n            gl.bindTexture(gl.TEXTURE_2D, texture);\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.tileWidth, this.tileHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n            tiles.push({\r\n                x: 0,\r\n                y: 0,\r\n                zoom: -1,\r\n                age: Number.MAX_VALUE / 2,\r\n                texture: texture\r\n            });\r\n        }\r\n        gl.bindTexture(gl.TEXTURE_2D, null);\r\n        this.tiles = tiles;\r\n    }\r\n    dispose(map, gl) {\r\n        if (this.tiles != null) {\r\n            this.tiles.forEach(tile => gl.deleteTexture(tile.texture));\r\n        }\r\n        this.tiles = null;\r\n        this.generator.dispose(map, gl);\r\n    }\r\n    getTileTexture(gl, x, y, zoom, dataBounds) {\r\n        const tiles = this.tiles;\r\n        if (tiles == null) {\r\n            throw Error('TileManager can not get a tile texture before it is initialised.');\r\n        }\r\n        if (!isTileInDataBounds(x, y, zoom, dataBounds)) {\r\n            return null;\r\n        }\r\n        const foundTile = tiles.find(t => t.x === x && t.y === y && t.zoom === zoom);\r\n        if (foundTile != null) {\r\n            foundTile.age = 0;\r\n            return foundTile.texture;\r\n        }\r\n        let leastUsedTile = tiles[0];\r\n        for (const tile of tiles) {\r\n            if (tile.age > leastUsedTile.age) {\r\n                leastUsedTile = tile;\r\n            }\r\n        }\r\n        leastUsedTile.x = x;\r\n        leastUsedTile.y = y;\r\n        leastUsedTile.zoom = zoom;\r\n        leastUsedTile.age = 0;\r\n        this.generator.generateTile(gl, leastUsedTile.texture, this.tileWidth, this.tileHeight, x, y, zoom);\r\n        return leastUsedTile.texture;\r\n    }\r\n    incrementAge() {\r\n        if (this.tiles == null) {\r\n            throw Error('TileManager can not increment age before it is initialised.');\r\n        }\r\n        for (const tile of this.tiles) {\r\n            tile.age++;\r\n        }\r\n    }\r\n}\r\nfunction isTileInDataBounds(x, y, zoom, bounds) {\r\n    if (bounds == null) {\r\n        return true;\r\n    }\r\n    const size = Math.pow(2, -zoom);\r\n    const tileMinX = x * size;\r\n    const tileMinY = y * size;\r\n    const tileMaxX = tileMinX + size;\r\n    const tileMaxY = tileMinY + size;\r\n    const minX = transformX(bounds.minX);\r\n    const minY = transformY(bounds.maxY);\r\n    const maxX = transformX(bounds.maxX);\r\n    const maxY = transformY(bounds.minY);\r\n    return tileMinX <= maxX &&\r\n        tileMaxX >= minX &&\r\n        tileMinY <= maxY &&\r\n        tileMaxY >= minY;\r\n}\r\n","import { TileManager } from './tile-manager';\r\nimport { TextureDrawer } from '../shader/texture-drawer/texture-drawer';\r\nimport { TileGenerator } from './tile-generator';\r\nimport { findViewBounds } from '../geometry-functions';\r\nexport class TileRenderer {\r\n    constructor(renderer, options) {\r\n        this.renderer = renderer;\r\n        this.textureDrawer = new TextureDrawer();\r\n        this.map = null;\r\n        this.viewBounds = {\r\n            minX: Infinity,\r\n            minY: Infinity,\r\n            maxX: -Infinity,\r\n            maxY: -Infinity\r\n        };\r\n        const numberOfTiles = options.numberOfTiles != null ? options.numberOfTiles : 16;\r\n        this.tileWidth = options.tileWidth != null ? options.tileWidth : 2048;\r\n        this.tileHeight = options.tileHeight != null ? options.tileHeight : 2048;\r\n        this.manager = new TileManager(new TileGenerator(renderer), numberOfTiles, this.tileWidth, this.tileHeight);\r\n    }\r\n    markAllTilesOutdated() {\r\n        this.manager.markAllTilesOutdated();\r\n    }\r\n    markOutdatedTiles(bounds) {\r\n        this.manager.markOutdatedTiles(bounds);\r\n    }\r\n    initialise(map, gl) {\r\n        this.manager.initialise(map, gl);\r\n        this.textureDrawer.initialise(gl);\r\n        this.map = map;\r\n    }\r\n    dispose(map, gl) {\r\n        this.map = null;\r\n        this.textureDrawer.dispose(gl);\r\n        this.manager.dispose(map, gl);\r\n    }\r\n    render(gl, matrix, dataBounds) {\r\n        if (this.map == null) {\r\n            throw Error('TiledRenderer can not render without being initialised.');\r\n        }\r\n        const viewportArray = gl.getParameter(gl.VIEWPORT);\r\n        const viewport = {\r\n            x: viewportArray[0],\r\n            y: viewportArray[1],\r\n            w: viewportArray[2],\r\n            h: viewportArray[3]\r\n        };\r\n        const bounds = this.viewBounds;\r\n        findViewBounds(bounds, this.map);\r\n        const equationFactor = Math.min(this.tileWidth * (bounds.maxX - bounds.minX) / viewport.w, this.tileHeight * (bounds.maxY - bounds.minY) / viewport.h);\r\n        const zoom = Math.ceil(-Math.log2(equationFactor));\r\n        const size = Math.pow(2, -zoom);\r\n        for (let x = Math.floor(bounds.minX / size); x * size < bounds.maxX; x++) {\r\n            for (let y = Math.floor(bounds.minY / size); y * size < bounds.maxY; y++) {\r\n                const texture = this.manager.getTileTexture(gl, x, y, zoom, dataBounds);\r\n                if (texture != null) {\r\n                    this.drawTile(gl, texture, matrix, x, y, zoom);\r\n                }\r\n            }\r\n        }\r\n        this.manager.incrementAge();\r\n    }\r\n    drawTile(gl, texture, matrix, x, y, zoom) {\r\n        const size = Math.pow(2, -zoom);\r\n        this.textureDrawer.draw(gl, texture, matrix, x * size, y * size, size, size);\r\n    }\r\n}\r\n","export function resolveVisibility(visibility, map) {\r\n    if (visibility == null) {\r\n        return true;\r\n    }\r\n    else if (typeof visibility === 'boolean') {\r\n        return visibility;\r\n    }\r\n    else if (map != null) {\r\n        return visibility(map);\r\n    }\r\n    else {\r\n        return true;\r\n    }\r\n}\r\n","import { resolveVisibility } from '../../shared/visibility';\r\nimport { pointToPointDistanceSqr } from '../../shared/geometry-functions';\r\nimport KDBush from 'kdbush';\r\nexport class KdBushClickProvider {\r\n    constructor(onClick, clickSize) {\r\n        this.onClick = onClick;\r\n        this.clickSize = clickSize;\r\n        this.map = null;\r\n        this.data = null;\r\n        this.index = null;\r\n        this.visibility = true;\r\n        this.clickHandler = (e) => {\r\n            if (this.map == null || this.data == null || this.index == null) {\r\n                return;\r\n            }\r\n            if (!resolveVisibility(this.visibility, this.map)) {\r\n                return;\r\n            }\r\n            const bounds = this.map.getBounds();\r\n            const canvas = this.map.getCanvas();\r\n            const clickSize = this.clickSize != null ? this.clickSize : 16;\r\n            const x = e.lngLat.lng;\r\n            const y = e.lngLat.lat;\r\n            const w = clickSize * (bounds.getEast() - bounds.getWest()) / canvas.width;\r\n            const h = clickSize * (bounds.getNorth() - bounds.getSouth()) / canvas.height;\r\n            const indices = this.index.range(x - 0.5 * w, y - 0.5 * h, x + 0.5 * w, y + 0.5 * h);\r\n            if (indices.length === 0) {\r\n                return;\r\n            }\r\n            let closestResultIndex = indices[0];\r\n            let minDistanceSqr = Infinity;\r\n            for (const i of indices) {\r\n                const result = this.data[i];\r\n                const distanceSqr = pointToPointDistanceSqr(x, y, result.x, result.y);\r\n                if (distanceSqr < minDistanceSqr) {\r\n                    closestResultIndex = i;\r\n                    minDistanceSqr = distanceSqr;\r\n                }\r\n            }\r\n            const size = Math.max(w, h);\r\n            const clickDistanceSqr = 0.25 * (size * size);\r\n            if (minDistanceSqr <= clickDistanceSqr) {\r\n                this.onClick(this.data[closestResultIndex].feature, e);\r\n            }\r\n        };\r\n    }\r\n    setData(data) {\r\n        const packedData = [];\r\n        for (const feature of data.features) {\r\n            if (feature.geometry.type === 'Point') {\r\n                const coords = feature.geometry.coordinates;\r\n                const packed = {\r\n                    feature: feature,\r\n                    x: coords[0],\r\n                    y: coords[1]\r\n                };\r\n                packedData.push(packed);\r\n            }\r\n            else if (feature.geometry.type === 'MultiPoint') {\r\n                const multiPoint = feature.geometry;\r\n                for (const coords of multiPoint.coordinates) {\r\n                    const packed = {\r\n                        feature: feature,\r\n                        x: coords[0],\r\n                        y: coords[1]\r\n                    };\r\n                    packedData.push(packed);\r\n                }\r\n            }\r\n        }\r\n        this.data = packedData;\r\n        this.index = new KDBush(packedData, p => p.x, p => p.y, 64, Float64Array);\r\n    }\r\n    clearData() {\r\n        this.index = null;\r\n        this.data = null;\r\n    }\r\n    initialise(map) {\r\n        this.map = map;\r\n        map.on('click', this.clickHandler);\r\n    }\r\n    dispose(map) {\r\n        this.map = null;\r\n        map.off('click', this.clickHandler);\r\n    }\r\n    setVisibility(visibility) {\r\n        this.visibility = visibility;\r\n    }\r\n}\r\n","import RBush from 'rbush';\r\nimport { packFeature } from '../../shared/geometry-functions';\r\nimport { resolveVisibility } from '../../shared/visibility';\r\nexport class RBushClickProvider {\r\n    constructor(resultsHandler, clickSize) {\r\n        this.resultsHandler = resultsHandler;\r\n        this.clickSize = clickSize;\r\n        this.map = null;\r\n        this.tree = null;\r\n        this.visibility = true;\r\n        this.clickHandler = (e) => {\r\n            if (this.map == null || this.tree == null) {\r\n                return;\r\n            }\r\n            if (!resolveVisibility(this.visibility, this.map)) {\r\n                return;\r\n            }\r\n            const bounds = this.map.getBounds();\r\n            const canvas = this.map.getCanvas();\r\n            const clickSize = this.clickSize != null ? this.clickSize : 16;\r\n            const x = e.lngLat.lng;\r\n            const y = e.lngLat.lat;\r\n            const w = clickSize * (bounds.getEast() - bounds.getWest()) / canvas.width;\r\n            const h = clickSize * (bounds.getNorth() - bounds.getSouth()) / canvas.height;\r\n            const results = this.tree.search({\r\n                minX: x - 0.5 * w,\r\n                minY: y - 0.5 * h,\r\n                maxX: x + 0.5 * w,\r\n                maxY: y + 0.5 * h\r\n            });\r\n            this.resultsHandler(x, y, Math.max(w, h), results, e);\r\n        };\r\n    }\r\n    setData(data) {\r\n        const packedData = data.features.map((feature, index) => packFeature(feature, index));\r\n        this.tree = new RBush();\r\n        this.tree.load(packedData);\r\n    }\r\n    clearData() {\r\n        this.tree = null;\r\n    }\r\n    initialise(map) {\r\n        this.map = map;\r\n        map.on('click', this.clickHandler);\r\n    }\r\n    dispose(map) {\r\n        this.map = null;\r\n        map.off('click', this.clickHandler);\r\n    }\r\n    setVisibility(visibility) {\r\n        this.visibility = visibility;\r\n    }\r\n}\r\n","import { lineRenderer } from '../renderer-preset/line-renderer';\r\nimport { StaticDataLayer } from '../static-data-layer';\r\nimport { lineToResultsClickHandler } from '../../shared/click-handler/line-click-handler';\r\nimport { RBushClickProvider } from '../click-provider/r-bush-click-provider';\r\nexport function lineLayer(options) {\r\n    return new StaticDataLayer({\r\n        id: options.id,\r\n        renderer: lineRenderer(options),\r\n        clickProvider: options.onClick != null ?\r\n            new RBushClickProvider(lineToResultsClickHandler(options.onClick), options.clickSize) : undefined\r\n    });\r\n}\r\n","import { pointRenderer } from '../renderer-preset/point-renderer';\r\nimport { StaticDataLayer } from '../static-data-layer';\r\nimport { KdBushClickProvider } from '../click-provider/kd-bush-click-provider';\r\nexport function pointLayer(options) {\r\n    return new StaticDataLayer({\r\n        id: options.id,\r\n        renderer: pointRenderer(options),\r\n        clickProvider: options.onClick != null ?\r\n            new KdBushClickProvider(options.onClick, options.clickSize) : undefined\r\n    });\r\n}\r\n","import { polygonRenderer } from '../renderer-preset/polygon-renderer';\r\nimport { StaticDataLayer } from '../static-data-layer';\r\nimport { polygonToResultsClickHandler } from '../../shared/click-handler/polygon-click-handler';\r\nimport { RBushClickProvider } from '../click-provider/r-bush-click-provider';\r\nexport function polygonLayer(options) {\r\n    return new StaticDataLayer({\r\n        id: options.id,\r\n        renderer: polygonRenderer(options),\r\n        clickProvider: options.onClick != null ?\r\n            new RBushClickProvider(polygonToResultsClickHandler(options.onClick), 0) : undefined\r\n    });\r\n}\r\n","import { FancyLineShader } from '../../shared/shader/line/fancy-line-shader';\r\nimport { SimpleLineShader } from '../../shared/shader/line/simple-line-shader';\r\nimport { SwitchRenderer } from '../renderer/switch-renderer';\r\nimport { ShaderRenderer } from '../renderer/shader-renderer';\r\nimport { TiledRenderer } from '../renderer/tiled-renderer';\r\nimport { simpleLinesToShaderBuffers } from '../vertex-data-mapper/simple-lines-to-shader-buffers';\r\nimport { fancyLinesToShaderBuffers } from '../vertex-data-mapper/fancy-lines-to-shader-buffers';\r\nexport function lineRenderer(options) {\r\n    const isSimple = options.simpleRendering != null && options.simpleRendering;\r\n    const shader = isSimple ? new SimpleLineShader() : new FancyLineShader(options.interpolation);\r\n    const dataMapper = isSimple ? simpleLinesToShaderBuffers : fancyLinesToShaderBuffers;\r\n    const threshold = options.tileThreshold != null ? options.tileThreshold : 10000;\r\n    return new SwitchRenderer([\r\n        {\r\n            renderer: new ShaderRenderer(shader, dataMapper),\r\n            condition: data => data.features.length < threshold\r\n        },\r\n        {\r\n            renderer: new TiledRenderer(new ShaderRenderer(shader, dataMapper), options),\r\n            condition: data => data.features.length >= threshold\r\n        }\r\n    ]);\r\n}\r\n","import { FancyPointShader } from '../../shared/shader/point/fancy-point-shader';\r\nimport { SimplePointShader } from '../../shared/shader/point/simple-point-shader';\r\nimport { SwitchRenderer } from '../renderer/switch-renderer';\r\nimport { ShaderRenderer } from '../renderer/shader-renderer';\r\nimport { TiledRenderer } from '../renderer/tiled-renderer';\r\nimport { simplePointsToShaderBuffers } from '../vertex-data-mapper/simple-points-to-shader-buffers';\r\nimport { fancyPointsToShaderBuffers } from '../vertex-data-mapper/fancy-points-to-shader-buffers';\r\nexport function pointRenderer(options) {\r\n    const isSimple = options.simpleRendering != null && options.simpleRendering;\r\n    const shader = isSimple ? new SimplePointShader(options.interpolation) : new FancyPointShader(options.interpolation);\r\n    const dataMapper = isSimple ? simplePointsToShaderBuffers : fancyPointsToShaderBuffers;\r\n    const threshold = options.tileThreshold != null ? options.tileThreshold : 100000;\r\n    return new SwitchRenderer([\r\n        {\r\n            renderer: new ShaderRenderer(shader, dataMapper),\r\n            condition: data => data.features.length < threshold\r\n        },\r\n        {\r\n            renderer: new TiledRenderer(new ShaderRenderer(shader, dataMapper), options),\r\n            condition: data => data.features.length >= threshold\r\n        }\r\n    ]);\r\n}\r\n","import { FancyPolygonShader } from '../../shared/shader/polygon/fancy-polygon-shader';\r\nimport { SimplePolygonShader } from '../../shared/shader/polygon/simple-polygon-shader';\r\nimport { SwitchRenderer } from '../renderer/switch-renderer';\r\nimport { ShaderRenderer } from '../renderer/shader-renderer';\r\nimport { TiledRenderer } from '../renderer/tiled-renderer';\r\nimport { simplePolygonsToShaderBuffers } from '../vertex-data-mapper/simple-polygons-to-shader-buffers';\r\nimport { fancyPolygonsToShaderBuffers } from '../vertex-data-mapper/fancy-polygons-to-shader-buffers';\r\nexport function polygonRenderer(options) {\r\n    const isSimple = options.simpleRendering != null && options.simpleRendering;\r\n    const shader = isSimple ? new SimplePolygonShader() : new FancyPolygonShader(options.interpolation);\r\n    const dataMapper = isSimple ? simplePolygonsToShaderBuffers : fancyPolygonsToShaderBuffers;\r\n    const threshold = options.tileThreshold != null ? options.tileThreshold : 10000;\r\n    return new SwitchRenderer([\r\n        {\r\n            renderer: new ShaderRenderer(shader, dataMapper),\r\n            condition: data => data.features.length < threshold\r\n        },\r\n        {\r\n            renderer: new TiledRenderer(new ShaderRenderer(shader, dataMapper), options),\r\n            condition: data => data.features.length >= threshold\r\n        }\r\n    ]);\r\n}\r\n","import { createShaderProgram } from '../../shared/shader/shader';\r\nexport class ShaderRenderer {\r\n    constructor(shader, vertexDataMapper) {\r\n        this.shader = shader;\r\n        this.vertexDataMapper = vertexDataMapper;\r\n        this.program = null;\r\n        this.arrayBuffer = null;\r\n        this.elementArrayBuffer = null;\r\n        this.array = new Float32Array([]);\r\n        this.elementArray = null;\r\n    }\r\n    setDataAndStyle(data, styleOption) {\r\n        const arrays = this.vertexDataMapper(data, styleOption);\r\n        this.array = arrays.array;\r\n        this.elementArray = arrays.elementArray;\r\n    }\r\n    clearData() {\r\n        this.array = new Float32Array([]);\r\n        this.elementArray = null;\r\n    }\r\n    initialise(map, gl) {\r\n        this.program = createShaderProgram(gl, this.shader.vertexSource, this.shader.fragmentSource);\r\n        this.arrayBuffer = gl.createBuffer();\r\n        this.elementArrayBuffer = gl.createBuffer();\r\n    }\r\n    dispose(map, gl) {\r\n        gl.deleteBuffer(this.elementArrayBuffer);\r\n        gl.deleteBuffer(this.arrayBuffer);\r\n        gl.deleteProgram(this.program);\r\n    }\r\n    prerender() {\r\n    }\r\n    render(gl, matrix) {\r\n        if (this.program == null) {\r\n            throw Error('ShaderRenderer can not render before it is initialised.');\r\n        }\r\n        gl.enable(gl.BLEND);\r\n        gl.blendEquation(gl.FUNC_ADD);\r\n        gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\r\n        gl.useProgram(this.program);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.arrayBuffer);\r\n        const cleanAttributes = this.shader.configureAttributes(gl, this.program);\r\n        gl.bufferData(gl.ARRAY_BUFFER, this.array, gl.STATIC_DRAW);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\r\n        this.shader.setUniforms(gl, this.program, matrix);\r\n        if (this.elementArray == null) {\r\n            gl.drawArrays(this.shader.getPrimitiveType(gl), 0, this.array.length / this.shader.getArrayBufferElementsPerVertex());\r\n        }\r\n        else {\r\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.elementArrayBuffer);\r\n            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.elementArray, gl.STATIC_DRAW);\r\n            gl.drawElements(this.shader.getPrimitiveType(gl), this.elementArray.length, gl.UNSIGNED_INT, 0);\r\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\r\n        }\r\n        cleanAttributes();\r\n    }\r\n}\r\n","export class SwitchRenderer {\r\n    constructor(options) {\r\n        this.options = options;\r\n        this.map = null;\r\n        this.gl = null;\r\n        this.currentOption = null;\r\n    }\r\n    setDataAndStyle(data, styleOption) {\r\n        const currentOption = this.currentOption;\r\n        if (currentOption == null || !currentOption.condition(data)) {\r\n            const newOption = this.options.find(option => option.condition(data));\r\n            if (newOption !== currentOption) {\r\n                if (currentOption != null) {\r\n                    currentOption.renderer.clearData();\r\n                }\r\n                if (this.map != null && this.gl != null) {\r\n                    if (currentOption != null) {\r\n                        currentOption.renderer.dispose(this.map, this.gl);\r\n                    }\r\n                    if (newOption != null) {\r\n                        newOption.renderer.initialise(this.map, this.gl);\r\n                    }\r\n                }\r\n                this.currentOption = newOption != null ? newOption : null;\r\n            }\r\n        }\r\n        if (this.currentOption != null) {\r\n            this.currentOption.renderer.setDataAndStyle(data, styleOption);\r\n        }\r\n    }\r\n    clearData() {\r\n        if (this.currentOption != null) {\r\n            this.currentOption.renderer.clearData();\r\n        }\r\n    }\r\n    initialise(map, gl) {\r\n        if (this.currentOption != null) {\r\n            this.currentOption.renderer.initialise(map, gl);\r\n        }\r\n        this.map = map;\r\n        this.gl = gl;\r\n    }\r\n    dispose(map, gl) {\r\n        this.gl = null;\r\n        this.map = null;\r\n        if (this.currentOption != null) {\r\n            this.currentOption.renderer.dispose(map, gl);\r\n        }\r\n    }\r\n    prerender(gl, matrix) {\r\n        if (this.currentOption != null) {\r\n            this.currentOption.renderer.prerender(gl, matrix);\r\n        }\r\n    }\r\n    render(gl, matrix) {\r\n        if (this.currentOption != null) {\r\n            this.currentOption.renderer.render(gl, matrix);\r\n        }\r\n    }\r\n}\r\n","import { findFeatureCollectionBounds } from '../../shared/geometry-functions';\r\nimport { TileRenderer } from '../../shared/tile/tile-renderer';\r\nexport class TiledRenderer {\r\n    constructor(renderer, options) {\r\n        this.renderer = renderer;\r\n        this.dataBounds = {\r\n            minX: Infinity,\r\n            minY: Infinity,\r\n            maxX: -Infinity,\r\n            maxY: -Infinity\r\n        };\r\n        this.tileRenderer = new TileRenderer(renderer, options);\r\n    }\r\n    setDataAndStyle(data, styleOption) {\r\n        findFeatureCollectionBounds(this.dataBounds, data);\r\n        this.renderer.setDataAndStyle(data, styleOption);\r\n        this.tileRenderer.markAllTilesOutdated();\r\n    }\r\n    clearData() {\r\n        this.renderer.clearData();\r\n        this.tileRenderer.markAllTilesOutdated();\r\n    }\r\n    initialise(map, gl) {\r\n        this.tileRenderer.initialise(map, gl);\r\n    }\r\n    dispose(map, gl) {\r\n        this.tileRenderer.dispose(map, gl);\r\n    }\r\n    prerender() {\r\n    }\r\n    render(gl, matrix) {\r\n        this.tileRenderer.render(gl, matrix, this.dataBounds);\r\n    }\r\n}\r\n","import { resolveVisibility } from '../shared/visibility';\r\nexport class StaticDataLayer {\r\n    constructor(options) {\r\n        this.options = options;\r\n        this.map = null;\r\n        this.data = null;\r\n        this.styleOption = undefined;\r\n        this.visibility = true;\r\n    }\r\n    get id() {\r\n        return this.options.id;\r\n    }\r\n    get renderingMode() {\r\n        if (this.options.renderingMode == null) {\r\n            return '2d';\r\n        }\r\n        return this.options.renderingMode;\r\n    }\r\n    get type() {\r\n        return 'custom';\r\n    }\r\n    setDataAndStyle(data, styleOption) {\r\n        this.data = data;\r\n        this.styleOption = styleOption;\r\n        this.options.renderer.setDataAndStyle(data, styleOption);\r\n        if (this.options.clickProvider != null) {\r\n            this.options.clickProvider.setData(data);\r\n        }\r\n        if (this.map != null) {\r\n            this.map.triggerRepaint();\r\n        }\r\n    }\r\n    setData(data) {\r\n        this.setDataAndStyle(data, this.styleOption);\r\n    }\r\n    setStyle(styleOption) {\r\n        this.styleOption = styleOption;\r\n        if (this.data == null) {\r\n            return;\r\n        }\r\n        this.options.renderer.setDataAndStyle(this.data, styleOption);\r\n        if (this.map != null) {\r\n            this.map.triggerRepaint();\r\n        }\r\n    }\r\n    clearData() {\r\n        this.data = null;\r\n        this.options.renderer.clearData();\r\n        if (this.options.clickProvider != null) {\r\n            this.options.clickProvider.clearData();\r\n        }\r\n        if (this.map != null) {\r\n            this.map.triggerRepaint();\r\n        }\r\n    }\r\n    setVisibility(visibility) {\r\n        this.visibility = visibility;\r\n        if (this.options.clickProvider != null) {\r\n            this.options.clickProvider.setVisibility(visibility);\r\n        }\r\n        if (this.map != null) {\r\n            this.map.triggerRepaint();\r\n        }\r\n    }\r\n    isVisible() {\r\n        return resolveVisibility(this.visibility, this.map);\r\n    }\r\n    onAdd(map, gl) {\r\n        gl.getExtension('OES_element_index_uint');\r\n        this.map = map;\r\n        this.options.renderer.initialise(map, gl);\r\n        if (this.options.clickProvider != null) {\r\n            this.options.clickProvider.initialise(map);\r\n        }\r\n    }\r\n    onRemove(map, gl) {\r\n        this.map = null;\r\n        this.options.renderer.dispose(map, gl);\r\n        if (this.options.clickProvider != null) {\r\n            this.options.clickProvider.dispose(map);\r\n        }\r\n    }\r\n    prerender(gl, matrix) {\r\n        if (this.isVisible()) {\r\n            this.options.renderer.prerender(gl, matrix);\r\n        }\r\n    }\r\n    render(gl, matrix) {\r\n        if (this.isVisible()) {\r\n            this.options.renderer.render(gl, matrix);\r\n        }\r\n    }\r\n}\r\n","import { resolveLineStyle } from '../../shared/styles';\r\nimport { cosOfPointsAngle, transformX, transformY } from '../../shared/geometry-functions';\r\nexport function fancyLinesToShaderBuffers(data, styleOption) {\r\n    const array = [];\r\n    const elementArray = [];\r\n    let currentIndex = 0;\r\n    function processSingleLine(coords, style) {\r\n        if (coords.length < 2) {\r\n            return;\r\n        }\r\n        for (let i = 0; i < coords.length; i++) {\r\n            const currentX = transformX(coords[i][0]);\r\n            const currentY = transformY(coords[i][1]);\r\n            let previousX, previousY, nextX, nextY;\r\n            if (i === 0) {\r\n                nextX = transformX(coords[i + 1][0]);\r\n                nextY = transformY(coords[i + 1][1]);\r\n                previousX = 2 * currentX - nextX;\r\n                previousY = 2 * currentY - nextY;\r\n            }\r\n            else if (i === coords.length - 1) {\r\n                previousX = transformX(coords[i - 1][0]);\r\n                previousY = transformY(coords[i - 1][1]);\r\n                nextX = 2 * currentX - previousX;\r\n                nextY = 2 * currentY - previousY;\r\n            }\r\n            else {\r\n                previousX = transformX(coords[i - 1][0]);\r\n                previousY = transformY(coords[i - 1][1]);\r\n                nextX = transformX(coords[i + 1][0]);\r\n                nextY = transformY(coords[i + 1][1]);\r\n            }\r\n            const cosAngle = cosOfPointsAngle(previousX, previousY, currentX, currentY, nextX, nextY);\r\n            if (cosAngle < 0.8) {\r\n                array.push(previousX, previousY, currentX, currentY, nextX, nextY, style.size, style.outlineSize, style.color.r, style.color.g, style.color.b, style.opacity, style.outlineColor.r, style.outlineColor.g, style.outlineColor.b, style.outlineOpacity, previousX, previousY, currentX, currentY, nextX, nextY, -style.size, -style.outlineSize, style.color.r, style.color.g, style.color.b, style.opacity, style.outlineColor.r, style.outlineColor.g, style.outlineColor.b, style.outlineOpacity);\r\n                if (i !== 0) {\r\n                    elementArray.push(currentIndex, currentIndex - 2, currentIndex - 1, currentIndex, currentIndex - 1, currentIndex + 1);\r\n                }\r\n                currentIndex += 2;\r\n            }\r\n            else {\r\n                const fakePreviousX = 2 * currentX - nextX;\r\n                const fakePreviousY = 2 * currentY - nextY;\r\n                const fakeNextX = 2 * currentX - previousX;\r\n                const fakeNextY = 2 * currentY - previousY;\r\n                array.push(previousX, previousY, currentX, currentY, fakeNextX, fakeNextY, style.size, style.outlineSize, style.color.r, style.color.g, style.color.b, style.opacity, style.outlineColor.r, style.outlineColor.g, style.outlineColor.b, style.outlineOpacity, previousX, previousY, currentX, currentY, fakeNextX, fakeNextY, -style.size, -style.outlineSize, style.color.r, style.color.g, style.color.b, style.opacity, style.outlineColor.r, style.outlineColor.g, style.outlineColor.b, style.outlineOpacity, fakePreviousX, fakePreviousY, currentX, currentY, nextX, nextY, style.size, style.outlineSize, style.color.r, style.color.g, style.color.b, style.opacity, style.outlineColor.r, style.outlineColor.g, style.outlineColor.b, style.outlineOpacity, fakePreviousX, fakePreviousY, currentX, currentY, nextX, nextY, -style.size, -style.outlineSize, style.color.r, style.color.g, style.color.b, style.opacity, style.outlineColor.r, style.outlineColor.g, style.outlineColor.b, style.outlineOpacity);\r\n                if (i !== 0) {\r\n                    elementArray.push(currentIndex, currentIndex - 2, currentIndex - 1, currentIndex, currentIndex - 1, currentIndex + 1);\r\n                }\r\n                currentIndex += 4;\r\n            }\r\n        }\r\n    }\r\n    const style = {};\r\n    for (const feature of data.features) {\r\n        resolveLineStyle(style, feature, styleOption);\r\n        if (feature.geometry.type === 'LineString') {\r\n            const geometry = feature.geometry;\r\n            processSingleLine(geometry.coordinates, style);\r\n        }\r\n        else if (feature.geometry.type === 'MultiLineString') {\r\n            const geometry = feature.geometry;\r\n            for (const coords of geometry.coordinates) {\r\n                processSingleLine(coords, style);\r\n            }\r\n        }\r\n    }\r\n    return {\r\n        array: new Float32Array(array),\r\n        elementArray: new Int32Array(elementArray)\r\n    };\r\n}\r\n","import { resolvePointStyle } from '../../shared/styles';\r\nimport { transformX, transformY } from '../../shared/geometry-functions';\r\nexport function fancyPointsToShaderBuffers(data, styleOption) {\r\n    const array = [];\r\n    function processSinglePoint(coords, style) {\r\n        array.push(transformX(coords[0]), transformY(coords[1]), style.size, style.color.r, style.color.g, style.color.b, style.opacity, style.outlineSize, style.outlineColor.r, style.outlineColor.g, style.outlineColor.b, style.outlineOpacity);\r\n    }\r\n    const style = {};\r\n    for (const feature of data.features) {\r\n        resolvePointStyle(style, feature, styleOption);\r\n        if (feature.geometry.type === 'Point') {\r\n            const geometry = feature.geometry;\r\n            processSinglePoint(geometry.coordinates, style);\r\n        }\r\n        else if (feature.geometry.type === 'MultiPoint') {\r\n            const geometry = feature.geometry;\r\n            for (const coords of geometry.coordinates) {\r\n                processSinglePoint(coords, style);\r\n            }\r\n        }\r\n    }\r\n    return {\r\n        array: new Float32Array(array),\r\n        elementArray: null\r\n    };\r\n}\r\n","import { resolvePolygonStyle } from '../../shared/styles';\r\nimport { cosOfPointsAngle, transformX, transformY } from '../../shared/geometry-functions';\r\nimport earcut from 'earcut';\r\nexport function fancyPolygonsToShaderBuffers(data, styleOption) {\r\n    const array = [];\r\n    const elementArray = [];\r\n    const indexMapper = [];\r\n    let currentIndex = 0;\r\n    function processSinglePolygon(coordinates, style) {\r\n        const transformedCoords = coordinates.map(c => c.map(coords => [transformX(coords[0]), transformY(coords[1])]));\r\n        indexMapper.length = 0;\r\n        for (const coords of transformedCoords) {\r\n            for (let i = 0; i < coords.length; i++) {\r\n                const previousIndex = i - 1 >= 0 ? i - 1 : coords.length - 2;\r\n                const nextIndex = i + 1 < coords.length ? i + 1 : 1;\r\n                const currentX = coords[i][0];\r\n                const currentY = coords[i][1];\r\n                const previousX = coords[previousIndex][0];\r\n                const previousY = coords[previousIndex][1];\r\n                const nextX = coords[nextIndex][0];\r\n                const nextY = coords[nextIndex][1];\r\n                const cosAngle = cosOfPointsAngle(previousX, previousY, currentX, currentY, nextX, nextY);\r\n                if (cosAngle < 0.8) {\r\n                    array.push(previousX, previousY, currentX, currentY, nextX, nextY, style.outlineSize, 0, style.color.r, style.color.g, style.color.b, style.opacity, style.outlineColor.r, style.outlineColor.g, style.outlineColor.b, style.outlineOpacity, previousX, previousY, currentX, currentY, nextX, nextY, style.outlineSize, 1, style.color.r, style.color.g, style.color.b, style.opacity, style.outlineColor.r, style.outlineColor.g, style.outlineColor.b, style.outlineOpacity);\r\n                    if (i !== 0) {\r\n                        elementArray.push(currentIndex, currentIndex - 2, currentIndex - 1, currentIndex, currentIndex - 1, currentIndex + 1);\r\n                    }\r\n                    indexMapper.push(currentIndex);\r\n                    currentIndex += 2;\r\n                }\r\n                else {\r\n                    const fakePreviousX = 2 * currentX - nextX;\r\n                    const fakePreviousY = 2 * currentY - nextY;\r\n                    const fakeNextX = 2 * currentX - previousX;\r\n                    const fakeNextY = 2 * currentY - previousY;\r\n                    array.push(previousX, previousY, currentX, currentY, fakeNextX, fakeNextY, style.outlineSize, 1, style.color.r, style.color.g, style.color.b, style.opacity, style.outlineColor.r, style.outlineColor.g, style.outlineColor.b, style.outlineOpacity, previousX, previousY, currentX, currentY, nextX, nextY, style.outlineSize, 0, style.color.r, style.color.g, style.color.b, style.opacity, style.outlineColor.r, style.outlineColor.g, style.outlineColor.b, style.outlineOpacity, fakePreviousX, fakePreviousY, currentX, currentY, nextX, nextY, style.outlineSize, 1, style.color.r, style.color.g, style.color.b, style.opacity, style.outlineColor.r, style.outlineColor.g, style.outlineColor.b, style.outlineOpacity);\r\n                    if (i !== 0) {\r\n                        elementArray.push(currentIndex + 1, currentIndex - 2, currentIndex - 1, currentIndex + 1, currentIndex - 1, currentIndex, currentIndex, currentIndex + 1, currentIndex + 2);\r\n                    }\r\n                    indexMapper.push(currentIndex + 1);\r\n                    currentIndex += 3;\r\n                }\r\n            }\r\n        }\r\n        const data = earcut.flatten(transformedCoords);\r\n        const triangles = earcut(data.vertices, data.holes, data.dimensions);\r\n        for (const index of triangles) {\r\n            elementArray.push(indexMapper[index]);\r\n        }\r\n    }\r\n    const style = {};\r\n    for (const feature of data.features) {\r\n        resolvePolygonStyle(style, feature, styleOption);\r\n        if (feature.geometry.type === 'Polygon') {\r\n            const geometry = feature.geometry;\r\n            processSinglePolygon(geometry.coordinates, style);\r\n        }\r\n        else if (feature.geometry.type === 'MultiPolygon') {\r\n            const geometry = feature.geometry;\r\n            for (const coords of geometry.coordinates) {\r\n                processSinglePolygon(coords, style);\r\n            }\r\n        }\r\n    }\r\n    return {\r\n        array: new Float32Array(array),\r\n        elementArray: new Int32Array(elementArray)\r\n    };\r\n}\r\n","import { resolveLineStyle } from '../../shared/styles';\r\nimport { transformX, transformY } from '../../shared/geometry-functions';\r\nexport function simpleLinesToShaderBuffers(data, styleOption) {\r\n    const array = [];\r\n    const elementsArray = [];\r\n    let currentIndex = 0;\r\n    function processSingleLine(coordinates, style) {\r\n        for (let i = 0; i < coordinates.length; i++) {\r\n            const coords = coordinates[i];\r\n            array.push(transformX(coords[0]), transformY(coords[1]), style.color.r, style.color.g, style.color.b, style.opacity);\r\n            if (i === 0 || i === coordinates.length - 1) {\r\n                elementsArray.push(currentIndex);\r\n            }\r\n            else {\r\n                elementsArray.push(currentIndex, currentIndex);\r\n            }\r\n            currentIndex++;\r\n        }\r\n    }\r\n    const style = {};\r\n    for (const feature of data.features) {\r\n        resolveLineStyle(style, feature, styleOption);\r\n        if (feature.geometry.type === 'LineString') {\r\n            const geometry = feature.geometry;\r\n            processSingleLine(geometry.coordinates, style);\r\n        }\r\n        else if (feature.geometry.type === 'MultiLineString') {\r\n            const geometry = feature.geometry;\r\n            for (const coords of geometry.coordinates) {\r\n                processSingleLine(coords, style);\r\n            }\r\n        }\r\n    }\r\n    return {\r\n        array: new Float32Array(array),\r\n        elementArray: new Int32Array(elementsArray)\r\n    };\r\n}\r\n","import { resolvePointStyle } from '../../shared/styles';\r\nimport { transformX, transformY } from '../../shared/geometry-functions';\r\nexport function simplePointsToShaderBuffers(data, styleOption) {\r\n    const array = [];\r\n    function processSinglePoint(coords, style) {\r\n        array.push(transformX(coords[0]), transformY(coords[1]), style.size, style.color.r, style.color.g, style.color.b, style.opacity);\r\n    }\r\n    const style = {};\r\n    for (const feature of data.features) {\r\n        resolvePointStyle(style, feature, styleOption);\r\n        if (feature.geometry.type === 'Point') {\r\n            const geometry = feature.geometry;\r\n            processSinglePoint(geometry.coordinates, style);\r\n        }\r\n        else if (feature.geometry.type === 'MultiPoint') {\r\n            const geometry = feature.geometry;\r\n            for (const coords of geometry.coordinates) {\r\n                processSinglePoint(coords, style);\r\n            }\r\n        }\r\n    }\r\n    return {\r\n        array: new Float32Array(array),\r\n        elementArray: null\r\n    };\r\n}\r\n","import { resolvePolygonStyle } from '../../shared/styles';\r\nimport { transformX, transformY } from '../../shared/geometry-functions';\r\nimport earcut from 'earcut';\r\nexport function simplePolygonsToShaderBuffers(data, styleOption) {\r\n    const array = [];\r\n    const elementArray = [];\r\n    let indexOffset = 0;\r\n    function processSinglePolygon(coordinates, style) {\r\n        const transformedCoordinates = coordinates.map(c => c.map(coords => [transformX(coords[0]), transformY(coords[1])]));\r\n        const data = earcut.flatten(transformedCoordinates);\r\n        for (let i = 0; i < data.vertices.length; i += 2) {\r\n            array.push(data.vertices[i], data.vertices[i + 1], style.color.r, style.color.g, style.color.b, style.opacity);\r\n        }\r\n        const triangles = earcut(data.vertices, data.holes, data.dimensions);\r\n        for (const index of triangles) {\r\n            elementArray.push(index + indexOffset);\r\n        }\r\n        indexOffset += data.vertices.length / 2;\r\n    }\r\n    const style = {};\r\n    for (const feature of data.features) {\r\n        resolvePolygonStyle(style, feature, styleOption);\r\n        if (feature.geometry.type === 'Polygon') {\r\n            const geometry = feature.geometry;\r\n            processSinglePolygon(geometry.coordinates, style);\r\n        }\r\n        else if (feature.geometry.type === 'MultiPolygon') {\r\n            const geometry = feature.geometry;\r\n            for (const coords of geometry.coordinates) {\r\n                processSinglePolygon(coords, style);\r\n            }\r\n        }\r\n    }\r\n    return {\r\n        array: new Float32Array(array),\r\n        elementArray: new Int32Array(elementArray)\r\n    };\r\n}\r\n","module.exports = __WEBPACK_EXTERNAL_MODULE_earcut__;","module.exports = __WEBPACK_EXTERNAL_MODULE_gl_matrix__;","module.exports = __WEBPACK_EXTERNAL_MODULE_kdbush__;","module.exports = __WEBPACK_EXTERNAL_MODULE_rbush__;"],"sourceRoot":""}