(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("earcut"), require("gl-matrix"), require("kdbush"), require("rbush"));
	else if(typeof define === 'function' && define.amd)
		define(["earcut", "gl-matrix", "kdbush", "rbush"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("earcut"), require("gl-matrix"), require("kdbush"), require("rbush")) : factory(root["earcut"], root["gl-matrix"], root["kdbush"], root["rbush"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(window, function(__WEBPACK_EXTERNAL_MODULE_earcut__, __WEBPACK_EXTERNAL_MODULE_gl_matrix__, __WEBPACK_EXTERNAL_MODULE_kdbush__, __WEBPACK_EXTERNAL_MODULE_rbush__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/dynamic-data/click-provider/dynamic-r-brush-click-provider.ts":
/*!***************************************************************************!*\
  !*** ./src/dynamic-data/click-provider/dynamic-r-brush-click-provider.ts ***!
  \***************************************************************************/
/*! exports provided: DynamicRBrushClickProvider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicRBrushClickProvider", function() { return DynamicRBrushClickProvider; });
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rbush */ "rbush");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rbush__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/geometry-functions */ "./src/shared/geometry-functions.ts");
/* harmony import */ var _shared_visibility__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/visibility */ "./src/shared/visibility.ts");



class DynamicRBrushClickProvider {
    constructor(resultsHandler, clickSize) {
        this.resultsHandler = resultsHandler;
        this.clickSize = clickSize;
        this.packedFeatures = [];
        this.tree = new rbush__WEBPACK_IMPORTED_MODULE_0___default.a();
        this.map = null;
        this.visibility = true;
        this.currentIndex = 0;
        this.dataOperations = {
            add: (feature) => {
                const packed = Object(_shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__["packFeature"])(feature, this.currentIndex);
                this.currentIndex++;
                this.packedFeatures.push(packed);
                this.tree.insert(packed);
            },
            removeFirst: () => {
                const packed = this.packedFeatures.shift();
                if (packed != null) {
                    this.tree.remove(packed);
                }
                return packed != null ? packed.feature : null;
            },
            removeLast: () => {
                const packed = this.packedFeatures.pop();
                if (packed != null) {
                    this.tree.remove(packed);
                }
                return packed != null ? packed.feature : null;
            },
            clear: () => {
                this.packedFeatures.length = 0;
                this.tree.clear();
            },
            getArray: () => {
                return this.packedFeatures.map(p => p.feature);
            },
            addAll: (features) => {
                const packed = features.map((f, index) => Object(_shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__["packFeature"])(f, this.currentIndex + index));
                this.currentIndex += features.length;
                this.packedFeatures.push(...packed);
                this.tree.load(packed);
            },
            removeNFirst: (n) => {
                let removed = [];
                for (let i = 0; i < n; i++) {
                    const r = this.dataOperations.removeFirst();
                    if (r != null) {
                        removed.push(r);
                    }
                }
                return removed;
            },
            removeNLast: (n) => {
                let removed = [];
                for (let i = 0; i < n; i++) {
                    const r = this.dataOperations.removeLast();
                    if (r != null) {
                        removed.unshift(r);
                    }
                }
                return removed;
            }
        };
        this.clickHandler = (e) => {
            if (this.map == null || this.tree == null) {
                return;
            }
            if (!Object(_shared_visibility__WEBPACK_IMPORTED_MODULE_2__["resolveVisibility"])(this.visibility, this.map)) {
                return;
            }
            const bounds = this.map.getBounds();
            const canvas = this.map.getCanvas();
            const clickSize = this.clickSize != null ? this.clickSize : 16;
            const x = e.lngLat.lng;
            const y = e.lngLat.lat;
            const w = clickSize * (bounds.getEast() - bounds.getWest()) / canvas.width;
            const h = clickSize * (bounds.getNorth() - bounds.getSouth()) / canvas.height;
            const results = this.tree.search({
                minX: x - 0.5 * w,
                minY: y - 0.5 * h,
                maxX: x + 0.5 * w,
                maxY: y + 0.5 * h
            });
            this.resultsHandler(x, y, Math.max(w, h), results, e);
        };
    }
    initialise(map) {
        this.map = map;
        map.on('click', this.clickHandler);
    }
    dispose(map) {
        this.map = null;
        map.off('click', this.clickHandler);
    }
    setVisibility(visibility) {
        this.visibility = visibility;
    }
}


/***/ }),

/***/ "./src/dynamic-data/data-operations.ts":
/*!*********************************************!*\
  !*** ./src/dynamic-data/data-operations.ts ***!
  \*********************************************/
/*! exports provided: BaseDataOperationsComposer, DataOperationsComposer, DataOperationsExtender */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseDataOperationsComposer", function() { return BaseDataOperationsComposer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataOperationsComposer", function() { return DataOperationsComposer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataOperationsExtender", function() { return DataOperationsExtender; });
class BaseDataOperationsComposer {
    constructor(sources, onDataChange) {
        this.sources = sources;
        this.onDataChange = onDataChange;
    }
    add(element) {
        for (const source of this.sources) {
            source.add(element);
        }
        if (this.onDataChange != null) {
            this.onDataChange();
        }
    }
    removeFirst() {
        let removed = null;
        for (const source of this.sources) {
            removed = source.removeFirst();
        }
        if (this.onDataChange != null) {
            this.onDataChange();
        }
        return removed;
    }
    removeLast() {
        let removed = null;
        for (const source of this.sources) {
            removed = source.removeLast();
        }
        if (this.onDataChange != null) {
            this.onDataChange();
        }
        return removed;
    }
    clear() {
        for (const source of this.sources) {
            source.clear();
        }
        if (this.onDataChange != null) {
            this.onDataChange();
        }
    }
    getArray() {
        if (this.sources.length == 0) {
            throw Error('No data sources provided.');
        }
        return this.sources[0].getArray();
    }
}
class DataOperationsComposer extends BaseDataOperationsComposer {
    constructor(sources, onDataChange) {
        super(sources, onDataChange);
        this.sources = sources;
    }
    addAll(elements) {
        for (const source of this.sources) {
            source.addAll(elements);
        }
        if (this.onDataChange != null) {
            this.onDataChange();
        }
    }
    removeNFirst(n) {
        let removed = null;
        for (const source of this.sources) {
            removed = source.removeNFirst(n);
        }
        if (this.onDataChange != null) {
            this.onDataChange();
        }
        return removed != null ? removed : [];
    }
    removeNLast(n) {
        let removed = null;
        for (const source of this.sources) {
            removed = source.removeNLast(n);
        }
        if (this.onDataChange != null) {
            this.onDataChange();
        }
        return removed != null ? removed : [];
    }
}
class DataOperationsExtender {
    constructor(source) {
        this.source = source;
    }
    add(element) {
        this.source.add(element);
    }
    removeFirst() {
        return this.source.removeFirst();
    }
    removeLast() {
        return this.source.removeLast();
    }
    clear() {
        this.source.clear();
    }
    getArray() {
        return this.source.getArray();
    }
    addAll(elements) {
        for (const element of elements) {
            this.source.add(element);
        }
    }
    removeNFirst(n) {
        let removed = [];
        for (let i = 0; i < n; i++) {
            const r = this.source.removeFirst();
            if (r != null) {
                removed.push(r);
            }
        }
        return removed;
    }
    removeNLast(n) {
        let removed = [];
        for (let i = 0; i < n; i++) {
            const r = this.source.removeLast();
            if (r != null) {
                removed.unshift(r);
            }
        }
        return removed;
    }
}


/***/ }),

/***/ "./src/dynamic-data/dynamic-data-layer.ts":
/*!************************************************!*\
  !*** ./src/dynamic-data/dynamic-data-layer.ts ***!
  \************************************************/
/*! exports provided: DynamicDataLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicDataLayer", function() { return DynamicDataLayer; });
/* harmony import */ var _shared_visibility__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/visibility */ "./src/shared/visibility.ts");
/* harmony import */ var _data_operations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data-operations */ "./src/dynamic-data/data-operations.ts");


class DynamicDataLayer {
    constructor(options) {
        this.options = options;
        this.map = null;
        this.visibility = true;
        this.dataOperations = new _data_operations__WEBPACK_IMPORTED_MODULE_1__["DataOperationsComposer"](this.options.clickProvider != null ?
            [this.options.renderer.dataOperations, this.options.clickProvider.dataOperations] :
            [this.options.renderer.dataOperations], () => {
            if (this.map != null) {
                this.map.triggerRepaint();
            }
        });
    }
    get id() {
        return this.options.id;
    }
    get renderingMode() {
        if (this.options.renderingMode == null) {
            return '2d';
        }
        return this.options.renderingMode;
    }
    get type() {
        return 'custom';
    }
    setStyle(styleOption) {
        this.options.renderer.setStyle(styleOption);
    }
    setVisibility(visibility) {
        this.visibility = visibility;
        if (this.options.clickProvider != null) {
            this.options.clickProvider.setVisibility(visibility);
        }
        if (this.map != null) {
            this.map.triggerRepaint();
        }
    }
    isVisible() {
        return Object(_shared_visibility__WEBPACK_IMPORTED_MODULE_0__["resolveVisibility"])(this.visibility, this.map);
    }
    onAdd(map, gl) {
        this.map = map;
        this.options.renderer.initialise(map, gl);
        if (this.options.clickProvider != null) {
            this.options.clickProvider.initialise(map);
        }
    }
    onRemove(map, gl) {
        this.map = null;
        this.options.renderer.dispose(map, gl);
        if (this.options.clickProvider != null) {
            this.options.clickProvider.dispose(map);
        }
    }
    prerender(gl, matrix) {
        if (this.isVisible()) {
            this.options.renderer.prerender(gl, matrix);
        }
    }
    render(gl, matrix) {
        if (this.isVisible()) {
            this.options.renderer.render(gl, matrix);
        }
    }
}


/***/ }),

/***/ "./src/dynamic-data/layer-preset/dynamic-point-layer.ts":
/*!**************************************************************!*\
  !*** ./src/dynamic-data/layer-preset/dynamic-point-layer.ts ***!
  \**************************************************************/
/*! exports provided: dynamicPointLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dynamicPointLayer", function() { return dynamicPointLayer; });
/* harmony import */ var _renderer_preset_dynamic_point_renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../renderer-preset/dynamic-point-renderer */ "./src/dynamic-data/renderer-preset/dynamic-point-renderer.ts");
/* harmony import */ var _dynamic_data_layer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dynamic-data-layer */ "./src/dynamic-data/dynamic-data-layer.ts");
/* harmony import */ var _shared_click_handler_point_click_handler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/click-handler/point-click-handler */ "./src/shared/click-handler/point-click-handler.ts");
/* harmony import */ var _click_provider_dynamic_r_brush_click_provider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../click-provider/dynamic-r-brush-click-provider */ "./src/dynamic-data/click-provider/dynamic-r-brush-click-provider.ts");




function dynamicPointLayer(options) {
    return new _dynamic_data_layer__WEBPACK_IMPORTED_MODULE_1__["DynamicDataLayer"]({
        id: options.id,
        renderer: Object(_renderer_preset_dynamic_point_renderer__WEBPACK_IMPORTED_MODULE_0__["dynamicPointRenderer"])(options),
        clickProvider: options.onClick != null ?
            new _click_provider_dynamic_r_brush_click_provider__WEBPACK_IMPORTED_MODULE_3__["DynamicRBrushClickProvider"](Object(_shared_click_handler_point_click_handler__WEBPACK_IMPORTED_MODULE_2__["pointToResultsClickHandler"])(options.onClick), options.clickSize) : undefined
    });
}


/***/ }),

/***/ "./src/dynamic-data/renderer-preset/dynamic-point-renderer.ts":
/*!********************************************************************!*\
  !*** ./src/dynamic-data/renderer-preset/dynamic-point-renderer.ts ***!
  \********************************************************************/
/*! exports provided: dynamicPointRenderer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dynamicPointRenderer", function() { return dynamicPointRenderer; });
/* harmony import */ var _shared_shader_point_simple_point_shader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/shader/point/simple-point-shader */ "./src/shared/shader/point/simple-point-shader.ts");
/* harmony import */ var _shared_shader_point_fancy_point_shader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/shader/point/fancy-point-shader */ "./src/shared/shader/point/fancy-point-shader.ts");
/* harmony import */ var _vertex_data_mapper_simple_point_to_vertex_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../vertex-data-mapper/simple-point-to-vertex-array */ "./src/dynamic-data/vertex-data-mapper/simple-point-to-vertex-array.ts");
/* harmony import */ var _vertex_data_mapper_fancy_point_to_vertex_array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../vertex-data-mapper/fancy-point-to-vertex-array */ "./src/dynamic-data/vertex-data-mapper/fancy-point-to-vertex-array.ts");
/* harmony import */ var _renderer_dynamic_shader_renderer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../renderer/dynamic-shader-renderer */ "./src/dynamic-data/renderer/dynamic-shader-renderer.ts");
/* harmony import */ var _renderer_dynamic_switch_renderer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../renderer/dynamic-switch-renderer */ "./src/dynamic-data/renderer/dynamic-switch-renderer.ts");
/* harmony import */ var _renderer_dynamic_tiled_renderer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../renderer/dynamic-tiled-renderer */ "./src/dynamic-data/renderer/dynamic-tiled-renderer.ts");







function dynamicPointRenderer(options) {
    const isSimple = options.simpleRendering != null && options.simpleRendering;
    const shaderRenderer = isSimple ?
        new _renderer_dynamic_shader_renderer__WEBPACK_IMPORTED_MODULE_4__["DynamicShaderRenderer"](new _shared_shader_point_simple_point_shader__WEBPACK_IMPORTED_MODULE_0__["SimplePointShader"](options.interpolation), _vertex_data_mapper_simple_point_to_vertex_array__WEBPACK_IMPORTED_MODULE_2__["simplePointToVertexArray"]) :
        new _renderer_dynamic_shader_renderer__WEBPACK_IMPORTED_MODULE_4__["DynamicShaderRenderer"](new _shared_shader_point_fancy_point_shader__WEBPACK_IMPORTED_MODULE_1__["FancyPointShader"](options.interpolation), _vertex_data_mapper_fancy_point_to_vertex_array__WEBPACK_IMPORTED_MODULE_3__["fancyPointToVertexArray"]);
    const threshold = options.tileThreshold != null ? options.tileThreshold : 100000;
    return new _renderer_dynamic_switch_renderer__WEBPACK_IMPORTED_MODULE_5__["DynamicSwitchRenderer"]([
        {
            renderer: shaderRenderer,
            condition: o => o.getArray().length < threshold
        },
        {
            renderer: new _renderer_dynamic_tiled_renderer__WEBPACK_IMPORTED_MODULE_6__["DynamicTiledRenderer"](shaderRenderer, options),
            condition: o => o.getArray().length >= threshold
        }
    ]);
}


/***/ }),

/***/ "./src/dynamic-data/renderer/dynamic-shader-data-collection.ts":
/*!*********************************************************************!*\
  !*** ./src/dynamic-data/renderer/dynamic-shader-data-collection.ts ***!
  \*********************************************************************/
/*! exports provided: DynamicShaderDataCollection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicShaderDataCollection", function() { return DynamicShaderDataCollection; });
class DynamicShaderDataCollection {
    constructor(vertexDataMapper, startingBufferSize) {
        this.vertexDataMapper = vertexDataMapper;
        this.styleOption = undefined;
        this.features = [];
        this.startIndex = 0;
        this.endIndex = 0;
        this.buffer = new Float32Array(startingBufferSize);
    }
    add(feature) {
        const mapped = this.vertexDataMapper(feature, this.styleOption);
        if (this.endIndex + mapped.length >= this.buffer.length) {
            this.resetBuffer();
        }
        this.buffer.set(mapped, this.endIndex);
        this.endIndex += mapped.length;
        this.features.push(feature);
    }
    removeFirst() {
        const feature = this.features.shift();
        if (feature != null) {
            const mapped = this.vertexDataMapper(feature, this.styleOption);
            this.startIndex += mapped.length;
        }
        return feature != null ? feature : null;
    }
    removeLast() {
        const feature = this.features.pop();
        if (feature != null) {
            const mapped = this.vertexDataMapper(feature, this.styleOption);
            this.endIndex -= mapped.length;
        }
        return feature != null ? feature : null;
    }
    clear() {
        this.features.length = 0;
        this.startIndex = 0;
        this.endIndex = 0;
    }
    setStyle(styleOption) {
        this.styleOption = styleOption;
        this.startIndex = 0;
        this.endIndex = 0;
        for (const feature of this.features) {
            const mapped = this.vertexDataMapper(feature, this.styleOption);
            this.buffer.set(mapped, this.endIndex);
            this.endIndex += mapped.length;
        }
    }
    resetBuffer() {
        const currentSize = this.endIndex - this.startIndex;
        this.buffer.copyWithin(0, this.startIndex, this.endIndex);
        this.startIndex = 0;
        this.endIndex = currentSize;
        if (this.buffer.length >= 2 * currentSize) {
            return;
        }
        const newBuffer = new Float32Array(2 * this.buffer.length);
        newBuffer.set(this.buffer);
        this.buffer = newBuffer;
    }
    getArray() {
        return this.features;
    }
    getVertexArray() {
        return this.buffer;
    }
    getStartIndex() {
        return this.startIndex;
    }
    getEndIndex() {
        return this.endIndex;
    }
}


/***/ }),

/***/ "./src/dynamic-data/renderer/dynamic-shader-renderer.ts":
/*!**************************************************************!*\
  !*** ./src/dynamic-data/renderer/dynamic-shader-renderer.ts ***!
  \**************************************************************/
/*! exports provided: DynamicShaderRenderer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicShaderRenderer", function() { return DynamicShaderRenderer; });
/* harmony import */ var _shared_shader_shader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/shader/shader */ "./src/shared/shader/shader.ts");
/* harmony import */ var _data_operations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../data-operations */ "./src/dynamic-data/data-operations.ts");
/* harmony import */ var _dynamic_shader_data_collection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dynamic-shader-data-collection */ "./src/dynamic-data/renderer/dynamic-shader-data-collection.ts");



class DynamicShaderRenderer {
    constructor(shader, vertexDataMapper, startingBufferSize = 512) {
        this.shader = shader;
        this.program = null;
        this.arrayBuffer = null;
        this.collection = new _dynamic_shader_data_collection__WEBPACK_IMPORTED_MODULE_2__["DynamicShaderDataCollection"](vertexDataMapper, startingBufferSize);
        this.dataOperations = new _data_operations__WEBPACK_IMPORTED_MODULE_1__["DataOperationsExtender"](this.collection);
    }
    setStyle(styleOption) {
        this.collection.setStyle(styleOption);
    }
    initialise(map, gl) {
        this.program = Object(_shared_shader_shader__WEBPACK_IMPORTED_MODULE_0__["createShaderProgram"])(gl, this.shader.vertexSource, this.shader.fragmentSource);
        this.arrayBuffer = gl.createBuffer();
    }
    dispose(map, gl) {
        gl.deleteBuffer(this.arrayBuffer);
        gl.deleteProgram(this.program);
    }
    prerender() {
    }
    render(gl, matrix) {
        if (this.program == null) {
            throw Error('ShaderRenderer can not render before it is initialised.');
        }
        gl.enable(gl.BLEND);
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        gl.useProgram(this.program);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.arrayBuffer);
        const cleanAttributes = this.shader.configureAttributes(gl, this.program);
        gl.bufferData(gl.ARRAY_BUFFER, this.collection.getVertexArray(), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        this.shader.setUniforms(gl, this.program, matrix);
        const startIndex = this.collection.getStartIndex();
        const endIndex = this.collection.getEndIndex();
        const elementsPerVertex = this.shader.getArrayBufferElementsPerVertex();
        gl.drawArrays(this.shader.getPrimitiveType(gl), startIndex / elementsPerVertex, (endIndex - startIndex) / elementsPerVertex);
        cleanAttributes();
    }
}


/***/ }),

/***/ "./src/dynamic-data/renderer/dynamic-switch-renderer.ts":
/*!**************************************************************!*\
  !*** ./src/dynamic-data/renderer/dynamic-switch-renderer.ts ***!
  \**************************************************************/
/*! exports provided: DynamicSwitchRenderer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicSwitchRenderer", function() { return DynamicSwitchRenderer; });
class DynamicSwitchRenderer {
    constructor(options, broadcastData = false) {
        this.options = options;
        this.broadcastData = broadcastData;
        this.map = null;
        this.gl = null;
        this.currentOption = null;
        this.dataOperations = {
            add: (element) => {
                if (this.broadcastData) {
                    for (const option of this.options) {
                        option.renderer.dataOperations.add(element);
                    }
                }
                else if (this.currentOption != null) {
                    this.currentOption.renderer.dataOperations.add(element);
                }
                this.handleDataChange();
            },
            removeFirst: () => {
                let removed = null;
                if (this.broadcastData) {
                    for (const option of this.options) {
                        removed = option.renderer.dataOperations.removeFirst();
                    }
                }
                else if (this.currentOption != null) {
                    removed = this.currentOption.renderer.dataOperations.removeFirst();
                }
                this.handleDataChange();
                return removed;
            },
            removeLast: () => {
                let removed = null;
                if (this.broadcastData) {
                    for (const option of this.options) {
                        removed = option.renderer.dataOperations.removeLast();
                    }
                }
                else if (this.currentOption != null) {
                    removed = this.currentOption.renderer.dataOperations.removeLast();
                }
                this.handleDataChange();
                return removed;
            },
            clear: () => {
                if (this.broadcastData) {
                    for (const option of this.options) {
                        option.renderer.dataOperations.clear();
                    }
                }
                else if (this.currentOption != null) {
                    this.currentOption.renderer.dataOperations.clear();
                }
                this.handleDataChange();
            },
            getArray: () => {
                if (this.currentOption != null) {
                    return this.currentOption.renderer.dataOperations.getArray();
                }
                return [];
            },
            addAll: (elements) => {
                if (this.broadcastData) {
                    for (const option of this.options) {
                        option.renderer.dataOperations.addAll(elements);
                    }
                }
                else if (this.currentOption != null) {
                    this.currentOption.renderer.dataOperations.addAll(elements);
                }
                this.handleDataChange();
            },
            removeNFirst: (n) => {
                let removed = null;
                if (this.broadcastData) {
                    for (const option of this.options) {
                        removed = option.renderer.dataOperations.removeNFirst(n);
                    }
                }
                else if (this.currentOption != null) {
                    removed = this.currentOption.renderer.dataOperations.removeNFirst(n);
                }
                this.handleDataChange();
                return removed != null ? removed : [];
            },
            removeNLast: (n) => {
                let removed = null;
                if (this.broadcastData) {
                    for (const option of this.options) {
                        removed = option.renderer.dataOperations.removeNLast(n);
                    }
                }
                else if (this.currentOption != null) {
                    removed = this.currentOption.renderer.dataOperations.removeNLast(n);
                }
                this.handleDataChange();
                return removed != null ? removed : [];
            }
        };
        this.handleDataChange();
    }
    setStyle(styleOption) {
        for (const option of this.options) {
            option.renderer.setStyle(styleOption);
        }
    }
    initialise(map, gl) {
        if (this.currentOption != null) {
            this.currentOption.renderer.initialise(map, gl);
        }
        this.map = map;
        this.gl = gl;
    }
    dispose(map, gl) {
        this.gl = null;
        this.map = null;
        if (this.currentOption != null) {
            this.currentOption.renderer.dispose(map, gl);
        }
    }
    prerender(gl, matrix) {
        if (this.currentOption != null) {
            this.currentOption.renderer.prerender(gl, matrix);
        }
    }
    render(gl, matrix) {
        if (this.currentOption != null) {
            this.currentOption.renderer.render(gl, matrix);
        }
    }
    handleDataChange() {
        const currentOption = this.currentOption;
        if (currentOption != null && currentOption.condition(currentOption.renderer.dataOperations)) {
            return;
        }
        const newOption = this.options.find(option => option.condition(option.renderer.dataOperations));
        if (newOption === currentOption) {
            return;
        }
        if (this.map != null && this.gl != null) {
            if (currentOption != null) {
                currentOption.renderer.dispose(this.map, this.gl);
            }
            if (newOption != null) {
                newOption.renderer.initialise(this.map, this.gl);
            }
        }
        this.currentOption = newOption != null ? newOption : null;
    }
}


/***/ }),

/***/ "./src/dynamic-data/renderer/dynamic-tiled-renderer.ts":
/*!*************************************************************!*\
  !*** ./src/dynamic-data/renderer/dynamic-tiled-renderer.ts ***!
  \*************************************************************/
/*! exports provided: DynamicTiledRenderer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicTiledRenderer", function() { return DynamicTiledRenderer; });
/* harmony import */ var _shared_tile_tile_renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/tile/tile-renderer */ "./src/shared/tile/tile-renderer.ts");
/* harmony import */ var _shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/geometry-functions */ "./src/shared/geometry-functions.ts");


class DynamicTiledRenderer {
    constructor(renderer, options) {
        this.renderer = renderer;
        this.dataBounds = {
            minX: Infinity,
            minY: Infinity,
            maxX: -Infinity,
            maxY: -Infinity
        };
        this.tempBounds = {
            minX: Infinity,
            minY: Infinity,
            maxX: -Infinity,
            maxY: -Infinity
        };
        this.dataOperations = {
            add: (feature) => {
                this.renderer.dataOperations.add(feature);
                this.handleDataChange(feature);
            },
            removeFirst: () => {
                const feature = this.renderer.dataOperations.removeFirst();
                if (feature != null) {
                    this.handleDataChange(feature);
                }
                return feature;
            },
            removeLast: () => {
                const feature = this.renderer.dataOperations.removeLast();
                if (feature != null) {
                    this.handleDataChange(feature);
                }
                return feature;
            },
            clear: () => {
                this.renderer.dataOperations.clear();
                this.tileRenderer.markAllTilesOutdated();
            },
            getArray: () => {
                return this.renderer.dataOperations.getArray();
            },
            addAll: (features) => {
                this.renderer.dataOperations.addAll(features);
                for (const feature of features) {
                    this.handleDataChange(feature);
                }
            },
            removeNFirst: (n) => {
                const features = this.renderer.dataOperations.removeNFirst(n);
                for (const feature of features) {
                    this.handleDataChange(feature);
                }
                return features;
            },
            removeNLast: (n) => {
                const features = this.renderer.dataOperations.removeNLast(n);
                for (const feature of features) {
                    this.handleDataChange(feature);
                }
                return features;
            }
        };
        this.tileRenderer = new _shared_tile_tile_renderer__WEBPACK_IMPORTED_MODULE_0__["TileRenderer"](renderer, options);
    }
    setStyle(styleOption) {
        this.renderer.setStyle(styleOption);
        this.tileRenderer.markAllTilesOutdated();
    }
    initialise(map, gl) {
        this.tileRenderer.initialise(map, gl);
    }
    dispose(map, gl) {
        this.tileRenderer.dispose(map, gl);
    }
    prerender() {
    }
    render(gl, matrix) {
        this.tileRenderer.render(gl, matrix, this.dataBounds);
    }
    handleDataChange(feature) {
        const bounds = this.tempBounds;
        Object(_shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__["findFeatureBounds"])(bounds, feature);
        this.tileRenderer.markOutdatedTiles(bounds);
        const dataBoundsChanged = this.dataBounds == null ||
            bounds.minX <= this.dataBounds.minX ||
            bounds.minY <= this.dataBounds.minY ||
            bounds.maxX >= this.dataBounds.maxX ||
            bounds.maxY >= this.dataBounds.maxY;
        if (dataBoundsChanged) {
            Object(_shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__["findFeaturesBounds"])(this.dataBounds, this.dataOperations.getArray());
        }
    }
}


/***/ }),

/***/ "./src/dynamic-data/vertex-data-mapper/fancy-point-to-vertex-array.ts":
/*!****************************************************************************!*\
  !*** ./src/dynamic-data/vertex-data-mapper/fancy-point-to-vertex-array.ts ***!
  \****************************************************************************/
/*! exports provided: fancyPointToVertexArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fancyPointToVertexArray", function() { return fancyPointToVertexArray; });
/* harmony import */ var _shared_styles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/styles */ "./src/shared/styles.ts");
/* harmony import */ var _shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/geometry-functions */ "./src/shared/geometry-functions.ts");


const style = {};
function fancyPointToVertexArray(feature, styleOption) {
    const array = [];
    Object(_shared_styles__WEBPACK_IMPORTED_MODULE_0__["resolvePointStyle"])(style, feature, styleOption);
    function processSinglePoint(coords) {
        array.push(Object(_shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__["transformX"])(coords[0]), Object(_shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__["transformY"])(coords[1]), style.size, style.color.r, style.color.g, style.color.b, style.opacity, style.outlineSize, style.outlineColor.r, style.outlineColor.g, style.outlineColor.b, style.outlineOpacity);
    }
    if (feature.geometry.type === 'Point') {
        const geometry = feature.geometry;
        processSinglePoint(geometry.coordinates);
    }
    else if (feature.geometry.type === 'MultiPoint') {
        const geometry = feature.geometry;
        for (const coords of geometry.coordinates) {
            processSinglePoint(coords);
        }
    }
    return array;
}


/***/ }),

/***/ "./src/dynamic-data/vertex-data-mapper/simple-point-to-vertex-array.ts":
/*!*****************************************************************************!*\
  !*** ./src/dynamic-data/vertex-data-mapper/simple-point-to-vertex-array.ts ***!
  \*****************************************************************************/
/*! exports provided: simplePointToVertexArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "simplePointToVertexArray", function() { return simplePointToVertexArray; });
/* harmony import */ var _shared_styles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/styles */ "./src/shared/styles.ts");
/* harmony import */ var _shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/geometry-functions */ "./src/shared/geometry-functions.ts");


const style = {};
function simplePointToVertexArray(feature, styleOption) {
    const array = [];
    Object(_shared_styles__WEBPACK_IMPORTED_MODULE_0__["resolvePointStyle"])(style, feature, styleOption);
    function processSinglePoint(coords) {
        array.push(Object(_shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__["transformX"])(coords[0]), Object(_shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__["transformY"])(coords[1]), style.size, style.color.r, style.color.g, style.color.b, style.opacity);
    }
    if (feature.geometry.type === 'Point') {
        const geometry = feature.geometry;
        processSinglePoint(geometry.coordinates);
    }
    else if (feature.geometry.type === 'MultiPoint') {
        const geometry = feature.geometry;
        for (const coords of geometry.coordinates) {
            processSinglePoint(coords);
        }
    }
    return array;
}


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! exports provided: StaticDataLayer, pointLayer, lineLayer, polygonLayer, DynamicDataLayer, dynamicPointLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _static_data_static_data_layer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./static-data/static-data-layer */ "./src/static-data/static-data-layer.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StaticDataLayer", function() { return _static_data_static_data_layer__WEBPACK_IMPORTED_MODULE_0__["StaticDataLayer"]; });

/* harmony import */ var _static_data_layer_preset_point_layer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./static-data/layer-preset/point-layer */ "./src/static-data/layer-preset/point-layer.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pointLayer", function() { return _static_data_layer_preset_point_layer__WEBPACK_IMPORTED_MODULE_1__["pointLayer"]; });

/* harmony import */ var _static_data_layer_preset_line_layer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./static-data/layer-preset/line-layer */ "./src/static-data/layer-preset/line-layer.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lineLayer", function() { return _static_data_layer_preset_line_layer__WEBPACK_IMPORTED_MODULE_2__["lineLayer"]; });

/* harmony import */ var _static_data_layer_preset_polygon_layer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./static-data/layer-preset/polygon-layer */ "./src/static-data/layer-preset/polygon-layer.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "polygonLayer", function() { return _static_data_layer_preset_polygon_layer__WEBPACK_IMPORTED_MODULE_3__["polygonLayer"]; });

/* harmony import */ var _dynamic_data_dynamic_data_layer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dynamic-data/dynamic-data-layer */ "./src/dynamic-data/dynamic-data-layer.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DynamicDataLayer", function() { return _dynamic_data_dynamic_data_layer__WEBPACK_IMPORTED_MODULE_4__["DynamicDataLayer"]; });

/* harmony import */ var _dynamic_data_layer_preset_dynamic_point_layer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dynamic-data/layer-preset/dynamic-point-layer */ "./src/dynamic-data/layer-preset/dynamic-point-layer.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dynamicPointLayer", function() { return _dynamic_data_layer_preset_dynamic_point_layer__WEBPACK_IMPORTED_MODULE_5__["dynamicPointLayer"]; });









/***/ }),

/***/ "./src/shared/click-handler/line-click-handler.ts":
/*!********************************************************!*\
  !*** ./src/shared/click-handler/line-click-handler.ts ***!
  \********************************************************/
/*! exports provided: lineToResultsClickHandler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineToResultsClickHandler", function() { return lineToResultsClickHandler; });
/* harmony import */ var _geometry_functions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry-functions */ "./src/shared/geometry-functions.ts");

function lineToResultsClickHandler(onClick) {
    return function (x, y, size, results, e) {
        let closestResult = results[0];
        let minDistanceSqr = Infinity;
        const closestPoint = { x: 0, y: 0 };
        const point = { x: 0, y: 0 };
        for (const result of results) {
            Object(_geometry_functions__WEBPACK_IMPORTED_MODULE_0__["closestPointOnLine"])(point, x, y, result.feature.geometry);
            const distanceSqr = Object(_geometry_functions__WEBPACK_IMPORTED_MODULE_0__["pointToPointDistanceSqr"])(x, y, point.x, point.y);
            if (distanceSqr < minDistanceSqr) {
                closestResult = result;
                minDistanceSqr = distanceSqr;
                closestPoint.x = point.x;
                closestPoint.y = point.y;
            }
        }
        const clickDistanceSqr = 0.25 * (size * size);
        if (minDistanceSqr <= clickDistanceSqr) {
            onClick(closestResult.feature, e, closestPoint);
        }
    };
}


/***/ }),

/***/ "./src/shared/click-handler/point-click-handler.ts":
/*!*********************************************************!*\
  !*** ./src/shared/click-handler/point-click-handler.ts ***!
  \*********************************************************/
/*! exports provided: pointToResultsClickHandler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointToResultsClickHandler", function() { return pointToResultsClickHandler; });
/* harmony import */ var _geometry_functions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry-functions */ "./src/shared/geometry-functions.ts");

function pointToResultsClickHandler(onClick) {
    return function (x, y, size, results, e) {
        let closestResult = results[0];
        let minDistanceSqr = Infinity;
        for (const result of results) {
            const distanceSqr = Object(_geometry_functions__WEBPACK_IMPORTED_MODULE_0__["pointToMultiPointDistanceSqr"])(x, y, result.feature.geometry);
            if (distanceSqr < minDistanceSqr) {
                closestResult = result;
                minDistanceSqr = distanceSqr;
            }
        }
        const clickDistanceSqr = 0.25 * (size * size);
        if (minDistanceSqr <= clickDistanceSqr) {
            onClick(closestResult.feature, e);
        }
    };
}


/***/ }),

/***/ "./src/shared/click-handler/polygon-click-handler.ts":
/*!***********************************************************!*\
  !*** ./src/shared/click-handler/polygon-click-handler.ts ***!
  \***********************************************************/
/*! exports provided: polygonToResultsClickHandler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polygonToResultsClickHandler", function() { return polygonToResultsClickHandler; });
/* harmony import */ var _geometry_functions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry-functions */ "./src/shared/geometry-functions.ts");

function polygonToResultsClickHandler(onClick) {
    return function (x, y, size, results, e) {
        let closestResult = null;
        let closestIndex = -1;
        for (const result of results) {
            if (result.index > closestIndex && Object(_geometry_functions__WEBPACK_IMPORTED_MODULE_0__["isPointInPolygon"])(x, y, result.feature.geometry)) {
                closestResult = result;
                closestIndex = result.index;
            }
        }
        if (closestResult != null) {
            onClick(closestResult.feature, e);
        }
    };
}


/***/ }),

/***/ "./src/shared/geometry-functions.ts":
/*!******************************************!*\
  !*** ./src/shared/geometry-functions.ts ***!
  \******************************************/
/*! exports provided: transformX, transformY, pointToPointDistanceSqr, pointToMultiPointDistanceSqr, closestPointOnLine, isPointInPolygon, cosOfPointsAngle, cosOfAngleBetweenVectors, findViewBounds, findFeatureCollectionBounds, findFeaturesBounds, findFeatureBounds, packFeature */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformX", function() { return transformX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformY", function() { return transformY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointToPointDistanceSqr", function() { return pointToPointDistanceSqr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointToMultiPointDistanceSqr", function() { return pointToMultiPointDistanceSqr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "closestPointOnLine", function() { return closestPointOnLine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPointInPolygon", function() { return isPointInPolygon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cosOfPointsAngle", function() { return cosOfPointsAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cosOfAngleBetweenVectors", function() { return cosOfAngleBetweenVectors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findViewBounds", function() { return findViewBounds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findFeatureCollectionBounds", function() { return findFeatureCollectionBounds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findFeaturesBounds", function() { return findFeaturesBounds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findFeatureBounds", function() { return findFeatureBounds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "packFeature", function() { return packFeature; });
function transformX(lng) {
    return (180 + lng) / 360;
}
function transformY(lat) {
    return (180 - (180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360)))) / 360;
}
function pointToPointDistanceSqr(x1, y1, x2, y2) {
    return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
}
function pointToMultiPointDistanceSqr(x, y, point) {
    if (point.type == 'Point') {
        const coords = point.coordinates;
        return pointToPointDistanceSqr(x, y, coords[0], coords[1]);
    }
    else {
        let minDistanceSqr = Infinity;
        for (const coords of point.coordinates) {
            const distanceSqr = pointToPointDistanceSqr(x, y, coords[0], coords[1]);
            if (distanceSqr < minDistanceSqr) {
                minDistanceSqr = distanceSqr;
            }
        }
        return minDistanceSqr;
    }
}
const tempPoint = { x: 0, y: 0 };
function closestPointOnLine(output, x, y, line) {
    if (line.type === 'LineString') {
        closestPointOnSingleLine(output, x, y, line.coordinates);
    }
    else {
        let minDistanceSqr = Infinity;
        let closestX = 0;
        let closestY = 0;
        for (const coords of line.coordinates) {
            const point = tempPoint;
            closestPointOnSingleLine(point, x, y, coords);
            const distanceSqr = pointToPointDistanceSqr(x, y, point.x, point.y);
            if (distanceSqr < minDistanceSqr) {
                minDistanceSqr = distanceSqr;
                closestX = point.x;
                closestY = point.y;
            }
        }
        output.x = closestX;
        output.y = closestY;
    }
}
function closestPointOnSingleLine(output, x, y, coordinates) {
    let minDistanceSqr = Infinity;
    let closestX = x;
    let closestY = y;
    for (let i = 0; i < coordinates.length - 1; i++) {
        const [x1, y1] = coordinates[i];
        const [x2, y2] = coordinates[i + 1];
        const segmentLengthSqr = pointToPointDistanceSqr(x1, y1, x2, y2);
        let projectionX = x1;
        let projectionY = y1;
        if (segmentLengthSqr > 0) {
            const projectionFactor = ((x - x1) * (x2 - x1) + (y - y1) * (y2 - y1)) / segmentLengthSqr;
            const projectionFactorClamped = Math.max(0, Math.min(1, projectionFactor));
            projectionX = x1 + projectionFactorClamped * (x2 - x1);
            projectionY = y1 + projectionFactorClamped * (y2 - y1);
        }
        const distanceSqr = pointToPointDistanceSqr(x, y, projectionX, projectionY);
        if (distanceSqr < minDistanceSqr) {
            minDistanceSqr = distanceSqr;
            closestX = projectionX;
            closestY = projectionY;
        }
    }
    output.x = closestX;
    output.y = closestY;
}
function isPointInPolygon(x, y, polygon) {
    if (polygon.type == 'Polygon') {
        return isPointInSinglePolygon(x, y, polygon.coordinates);
    }
    else {
        for (const coords of polygon.coordinates) {
            if (isPointInSinglePolygon(x, y, coords)) {
                return true;
            }
        }
        return false;
    }
}
function isPointInSinglePolygon(x, y, coordinates) {
    if (coordinates.length === 0 || !isPointInPolygonNoHoles(x, y, coordinates[0])) {
        return false;
    }
    for (let i = 1; i < coordinates.length; i++) {
        const coords = coordinates[i];
        if (isPointInPolygonNoHoles(x, y, coords)) {
            return false;
        }
    }
    return true;
}
function isPointInPolygonNoHoles(x, y, coords) {
    let isInside = false;
    for (let i = 0, j = coords.length - 1; i < coords.length; j = i++) {
        const xi = coords[i][0], yi = coords[i][1];
        const xj = coords[j][0], yj = coords[j][1];
        const doseIntersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (doseIntersect) {
            isInside = !isInside;
        }
    }
    return isInside;
}
function cosOfPointsAngle(x1, y1, x2, y2, x3, y3) {
    return cosOfAngleBetweenVectors(x2 - x1, y2 - y1, x2 - x3, y2 - y3);
}
function cosOfAngleBetweenVectors(x1, y1, x2, y2) {
    const dot = x1 * x2 + y1 * y2;
    const length1 = Math.sqrt(x1 * x1 + y1 * y1);
    const length2 = Math.sqrt(x2 * x2 + y2 * y2);
    return dot / (length1 * length2);
}
function findViewBounds(output, map) {
    const bounds = map.getBounds();
    output.minX = transformX(bounds.getWest());
    output.minY = transformY(bounds.getNorth());
    output.maxX = transformX(bounds.getEast());
    output.maxY = transformY(bounds.getSouth());
}
function findFeatureCollectionBounds(output, featureCollection) {
    output.minX = Infinity;
    output.minY = Infinity;
    output.maxX = -Infinity;
    output.maxY = -Infinity;
    for (const feature of featureCollection.features) {
        findGeometryBounds(output, feature.geometry);
    }
}
function findFeaturesBounds(output, features) {
    output.minX = Infinity;
    output.minY = Infinity;
    output.maxX = -Infinity;
    output.maxY = -Infinity;
    for (const feature of features) {
        findGeometryBounds(output, feature.geometry);
    }
}
function findFeatureBounds(output, feature) {
    output.minX = Infinity;
    output.minY = Infinity;
    output.maxX = -Infinity;
    output.maxY = -Infinity;
    findGeometryBounds(output, feature.geometry);
}
function findGeometryBounds(output, geometry) {
    if (geometry.type === 'GeometryCollection') {
        for (const g of geometry.geometries) {
            findGeometryBounds(output, g);
        }
    }
    else {
        findCoordinatesBounds(output, geometry.coordinates);
    }
}
function findCoordinatesBounds(output, coords) {
    for (let i = 0; i < coords.length; i++) {
        const c = coords[i];
        if (typeof c === 'number') {
            if (i === 0) {
                if (c < output.minX)
                    output.minX = c;
                if (c > output.maxX)
                    output.maxX = c;
            }
            else if (i === 1) {
                if (c < output.minY)
                    output.minY = c;
                if (c > output.maxY)
                    output.maxY = c;
            }
        }
        else {
            findCoordinatesBounds(output, c);
        }
    }
}
function packFeature(feature, index) {
    const packed = {
        feature: feature,
        index: index,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
    };
    findFeatureBounds(packed, feature);
    return packed;
}


/***/ }),

/***/ "./src/shared/shader/default/default-shader.ts":
/*!*****************************************************!*\
  !*** ./src/shared/shader/default/default-shader.ts ***!
  \*****************************************************/
/*! exports provided: DefaultShader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultShader", function() { return DefaultShader; });
/* harmony import */ var _default_vert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./default.vert */ "./src/shared/shader/default/default.vert");
/* harmony import */ var _default_vert__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_default_vert__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _default_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./default.frag */ "./src/shared/shader/default/default.frag");
/* harmony import */ var _default_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_default_frag__WEBPACK_IMPORTED_MODULE_1__);


class DefaultShader {
    constructor() {
        this.vertexSource = _default_vert__WEBPACK_IMPORTED_MODULE_0___default.a;
        this.fragmentSource = _default_frag__WEBPACK_IMPORTED_MODULE_1___default.a;
    }
    configureAttributes(gl, program) {
        const position = gl.getAttribLocation(program, 'a_position');
        const color = gl.getAttribLocation(program, 'a_color');
        const vertexSize = 6 * Float32Array.BYTES_PER_ELEMENT;
        gl.vertexAttribPointer(position, 2, gl.FLOAT, false, vertexSize, 0);
        gl.vertexAttribPointer(color, 4, gl.FLOAT, false, vertexSize, 2 * Float32Array.BYTES_PER_ELEMENT);
        gl.enableVertexAttribArray(position);
        gl.enableVertexAttribArray(color);
        return () => {
            gl.disableVertexAttribArray(position);
            gl.disableVertexAttribArray(color);
        };
    }
    getArrayBufferElementsPerVertex() {
        return 6;
    }
    setUniforms(gl, program, matrix) {
        gl.uniformMatrix4fv(gl.getUniformLocation(program, 'u_matrix'), false, matrix);
    }
}


/***/ }),

/***/ "./src/shared/shader/default/default.frag":
/*!************************************************!*\
  !*** ./src/shared/shader/default/default.frag ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision mediump float;\r\n\r\nvarying vec4 v_color;\r\n\r\nvoid main() {\r\n    gl_FragColor = v_color;\r\n}\r\n"

/***/ }),

/***/ "./src/shared/shader/default/default.vert":
/*!************************************************!*\
  !*** ./src/shared/shader/default/default.vert ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision mediump float;\r\n\r\nuniform mat4 u_matrix;\r\n\r\nattribute vec2 a_position;\r\nattribute vec4 a_color;\r\n\r\nvarying vec4 v_color;\r\n\r\nvoid main() {\r\n    v_color = a_color;\r\n    gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\r\n}\r\n"

/***/ }),

/***/ "./src/shared/shader/line/fancy-line-shader.ts":
/*!*****************************************************!*\
  !*** ./src/shared/shader/line/fancy-line-shader.ts ***!
  \*****************************************************/
/*! exports provided: FancyLineShader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FancyLineShader", function() { return FancyLineShader; });
/* harmony import */ var _fancy_line_vert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fancy-line.vert */ "./src/shared/shader/line/fancy-line.vert");
/* harmony import */ var _fancy_line_vert__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_fancy_line_vert__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _fancy_line_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fancy-line.frag */ "./src/shared/shader/line/fancy-line.frag");
/* harmony import */ var _fancy_line_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_fancy_line_frag__WEBPACK_IMPORTED_MODULE_1__);


class FancyLineShader {
    constructor(interpolation = 1.8) {
        this.interpolation = interpolation;
        this.vertexSource = _fancy_line_vert__WEBPACK_IMPORTED_MODULE_0___default.a;
        this.fragmentSource = _fancy_line_frag__WEBPACK_IMPORTED_MODULE_1___default.a;
    }
    configureAttributes(gl, program) {
        const previousPosition = gl.getAttribLocation(program, 'a_previousPosition');
        const currentPosition = gl.getAttribLocation(program, 'a_currentPosition');
        const nextPosition = gl.getAttribLocation(program, 'a_nextPosition');
        const size = gl.getAttribLocation(program, 'a_size');
        const color = gl.getAttribLocation(program, 'a_color');
        const outlineSize = gl.getAttribLocation(program, 'a_outlineSize');
        const outlineColor = gl.getAttribLocation(program, 'a_outlineColor');
        const vertexSize = 16 * Float32Array.BYTES_PER_ELEMENT;
        gl.vertexAttribPointer(previousPosition, 2, gl.FLOAT, false, vertexSize, 0);
        gl.vertexAttribPointer(currentPosition, 2, gl.FLOAT, false, vertexSize, 2 * Float32Array.BYTES_PER_ELEMENT);
        gl.vertexAttribPointer(nextPosition, 2, gl.FLOAT, false, vertexSize, 4 * Float32Array.BYTES_PER_ELEMENT);
        gl.vertexAttribPointer(size, 1, gl.FLOAT, false, vertexSize, 6 * Float32Array.BYTES_PER_ELEMENT);
        gl.vertexAttribPointer(outlineSize, 1, gl.FLOAT, false, vertexSize, 7 * Float32Array.BYTES_PER_ELEMENT);
        gl.vertexAttribPointer(color, 4, gl.FLOAT, false, vertexSize, 8 * Float32Array.BYTES_PER_ELEMENT);
        gl.vertexAttribPointer(outlineColor, 4, gl.FLOAT, false, vertexSize, 12 * Float32Array.BYTES_PER_ELEMENT);
        gl.enableVertexAttribArray(previousPosition);
        gl.enableVertexAttribArray(currentPosition);
        gl.enableVertexAttribArray(nextPosition);
        gl.enableVertexAttribArray(size);
        gl.enableVertexAttribArray(color);
        gl.enableVertexAttribArray(outlineSize);
        gl.enableVertexAttribArray(outlineColor);
        return () => {
            gl.disableVertexAttribArray(previousPosition);
            gl.disableVertexAttribArray(currentPosition);
            gl.disableVertexAttribArray(nextPosition);
            gl.disableVertexAttribArray(size);
            gl.disableVertexAttribArray(color);
            gl.disableVertexAttribArray(outlineSize);
            gl.disableVertexAttribArray(outlineColor);
        };
    }
    setUniforms(gl, program, matrix) {
        const viewport = gl.getParameter(gl.VIEWPORT);
        gl.uniformMatrix4fv(gl.getUniformLocation(program, 'u_matrix'), false, matrix);
        gl.uniform2f(gl.getUniformLocation(program, 'u_viewPortSize'), viewport[2], viewport[3]);
        gl.uniform1f(gl.getUniformLocation(program, 'u_interpolation'), this.interpolation);
    }
    getArrayBufferElementsPerVertex() {
        return 16;
    }
    getPrimitiveType(gl) {
        return gl.TRIANGLES;
    }
}


/***/ }),

/***/ "./src/shared/shader/line/fancy-line.frag":
/*!************************************************!*\
  !*** ./src/shared/shader/line/fancy-line.frag ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision mediump float;\r\n\r\nuniform float u_interpolation;\r\n\r\nvarying float v_halfSize;\r\nvarying float v_outlineSize;\r\nvarying vec4 v_color;\r\nvarying vec4 v_outlineColor;\r\nvarying float v_distance;\r\n\r\nvoid main() {\r\n    float dist = abs(v_distance);\r\n    bool branch = dist < v_halfSize;\r\n    float x = branch ? dist - v_halfSize : dist - v_halfSize - v_outlineSize;\r\n    vec4 color1 = branch ? v_color : v_outlineColor;\r\n    vec4 color2 = branch ? v_outlineColor : vec4(v_outlineColor.rgb, 0.0);\r\n    float m = smoothstep(-u_interpolation, 0.0, x);\r\n    gl_FragColor = mix(color1, color2, m);\r\n}\r\n"

/***/ }),

/***/ "./src/shared/shader/line/fancy-line.vert":
/*!************************************************!*\
  !*** ./src/shared/shader/line/fancy-line.vert ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision mediump float;\r\n\r\nuniform mat4 u_matrix;\r\nuniform vec2 u_viewPortSize;\r\n\r\nattribute vec2 a_previousPosition;\r\nattribute vec2 a_currentPosition;\r\nattribute vec2 a_nextPosition;\r\nattribute float a_size;\r\nattribute float a_outlineSize;\r\nattribute vec4 a_color;\r\nattribute vec4 a_outlineColor;\r\n\r\nvarying float v_halfSize;\r\nvarying float v_outlineSize;\r\nvarying vec4 v_color;\r\nvarying vec4 v_outlineColor;\r\nvarying float v_distance;\r\n\r\nvoid main() {\r\n    v_halfSize = abs(0.5 * a_size);\r\n    v_outlineSize = abs(a_outlineSize);\r\n    v_color = a_color;\r\n    v_outlineColor = a_outlineColor;\r\n    v_distance = 0.5 * a_size + a_outlineSize;\r\n\r\n    vec4 previousProjected = u_matrix * vec4(a_previousPosition, 0.0, 1.0);\r\n    vec4 currentProjected = u_matrix * vec4(a_currentPosition, 0.0, 1.0);\r\n    vec4 nextProjected = u_matrix * vec4(a_nextPosition, 0.0, 1.0);\r\n\r\n    vec2 previousScreen = previousProjected.xy / previousProjected.w * u_viewPortSize;\r\n    vec2 currentScreen = currentProjected.xy / currentProjected.w * u_viewPortSize;\r\n    vec2 nextScreen = nextProjected.xy / nextProjected.w * u_viewPortSize;\r\n\r\n    vec2 dirA = normalize(currentScreen - previousScreen);\r\n    vec2 dirB = normalize(nextScreen - currentScreen);\r\n    vec2 tangent = normalize(dirA + dirB);\r\n    vec2 perp = vec2(-dirA.y, dirA.x);\r\n\r\n    vec2 normal = vec2(-tangent.y, tangent.x);\r\n    vec2 offset = (2.0 * v_distance / max(dot(normal, perp), 0.1) * normal) / u_viewPortSize;\r\n\r\n    gl_Position = vec4(currentProjected.xy / max(currentProjected.w, 0.0001) + offset, 0.0, 1.0);\r\n}\r\n"

/***/ }),

/***/ "./src/shared/shader/line/simple-line-shader.ts":
/*!******************************************************!*\
  !*** ./src/shared/shader/line/simple-line-shader.ts ***!
  \******************************************************/
/*! exports provided: SimpleLineShader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SimpleLineShader", function() { return SimpleLineShader; });
/* harmony import */ var _default_default_shader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../default/default-shader */ "./src/shared/shader/default/default-shader.ts");

class SimpleLineShader extends _default_default_shader__WEBPACK_IMPORTED_MODULE_0__["DefaultShader"] {
    getPrimitiveType(gl) {
        return gl.LINES;
    }
}


/***/ }),

/***/ "./src/shared/shader/point/fancy-point-shader.ts":
/*!*******************************************************!*\
  !*** ./src/shared/shader/point/fancy-point-shader.ts ***!
  \*******************************************************/
/*! exports provided: FancyPointShader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FancyPointShader", function() { return FancyPointShader; });
/* harmony import */ var _fancy_point_vert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fancy-point.vert */ "./src/shared/shader/point/fancy-point.vert");
/* harmony import */ var _fancy_point_vert__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_fancy_point_vert__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _fancy_point_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fancy-point.frag */ "./src/shared/shader/point/fancy-point.frag");
/* harmony import */ var _fancy_point_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_fancy_point_frag__WEBPACK_IMPORTED_MODULE_1__);


class FancyPointShader {
    constructor(interpolation = 1.8) {
        this.interpolation = interpolation;
        this.vertexSource = _fancy_point_vert__WEBPACK_IMPORTED_MODULE_0___default.a;
        this.fragmentSource = _fancy_point_frag__WEBPACK_IMPORTED_MODULE_1___default.a;
    }
    configureAttributes(gl, program) {
        const position = gl.getAttribLocation(program, 'a_position');
        const size = gl.getAttribLocation(program, 'a_size');
        const color = gl.getAttribLocation(program, 'a_color');
        const outlineSize = gl.getAttribLocation(program, 'a_outlineSize');
        const outlineColor = gl.getAttribLocation(program, 'a_outlineColor');
        const vertexSize = 12 * Float32Array.BYTES_PER_ELEMENT;
        gl.vertexAttribPointer(position, 2, gl.FLOAT, false, vertexSize, 0);
        gl.vertexAttribPointer(size, 1, gl.FLOAT, false, vertexSize, 2 * Float32Array.BYTES_PER_ELEMENT);
        gl.vertexAttribPointer(color, 4, gl.FLOAT, false, vertexSize, 3 * Float32Array.BYTES_PER_ELEMENT);
        gl.vertexAttribPointer(outlineSize, 1, gl.FLOAT, false, vertexSize, 7 * Float32Array.BYTES_PER_ELEMENT);
        gl.vertexAttribPointer(outlineColor, 4, gl.FLOAT, false, vertexSize, 8 * Float32Array.BYTES_PER_ELEMENT);
        gl.enableVertexAttribArray(position);
        gl.enableVertexAttribArray(size);
        gl.enableVertexAttribArray(color);
        gl.enableVertexAttribArray(outlineSize);
        gl.enableVertexAttribArray(outlineColor);
        return () => {
            gl.disableVertexAttribArray(position);
            gl.disableVertexAttribArray(size);
            gl.disableVertexAttribArray(color);
            gl.disableVertexAttribArray(outlineSize);
            gl.disableVertexAttribArray(outlineColor);
        };
    }
    setUniforms(gl, program, matrix) {
        gl.uniformMatrix4fv(gl.getUniformLocation(program, 'u_matrix'), false, matrix);
        gl.uniform1f(gl.getUniformLocation(program, 'u_interpolation'), this.interpolation);
    }
    getArrayBufferElementsPerVertex() {
        return 12;
    }
    getPrimitiveType(gl) {
        return gl.POINTS;
    }
}


/***/ }),

/***/ "./src/shared/shader/point/fancy-point.frag":
/*!**************************************************!*\
  !*** ./src/shared/shader/point/fancy-point.frag ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision mediump float;\r\n\r\nuniform float u_interpolation;\r\n\r\nvarying float v_size;\r\nvarying vec4 v_color;\r\nvarying float v_outlineSize;\r\nvarying vec4 v_outlineColor;\r\nvarying float v_pointSize;\r\nvarying float v_halfSize;\r\n\r\nvoid main() {\r\n    float dist = v_pointSize * distance(gl_PointCoord, vec2(0.5, 0.5));\r\n    bool branch = dist < v_halfSize;\r\n    float x = branch ? dist - v_halfSize : dist - v_halfSize - v_outlineSize;\r\n    vec4 color1 = branch ? v_color : v_outlineColor;\r\n    vec4 color2 = branch ? v_outlineColor : vec4(v_outlineColor.rgb, 0.0);\r\n    float m = smoothstep(-u_interpolation, 0.0, x);\r\n    gl_FragColor = mix(color1, color2, m);\r\n}\r\n"

/***/ }),

/***/ "./src/shared/shader/point/fancy-point.vert":
/*!**************************************************!*\
  !*** ./src/shared/shader/point/fancy-point.vert ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision mediump float;\r\n\r\nuniform mat4 u_matrix;\r\n\r\nattribute vec2 a_position;\r\nattribute float a_size;\r\nattribute vec4 a_color;\r\nattribute float a_outlineSize;\r\nattribute vec4 a_outlineColor;\r\n\r\nvarying float v_size;\r\nvarying vec4 v_color;\r\nvarying float v_outlineSize;\r\nvarying vec4 v_outlineColor;\r\nvarying float v_pointSize;\r\nvarying float v_halfSize;\r\n\r\nvoid main() {\r\n    v_size = a_size;\r\n    v_color = a_color;\r\n    v_outlineSize = a_outlineSize;\r\n    v_outlineColor = a_outlineColor;\r\n    v_pointSize = a_size + 2.0*a_outlineSize;\r\n    v_halfSize = 0.5*v_size;\r\n\r\n    gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\r\n    gl_PointSize = v_pointSize;\r\n}\r\n"

/***/ }),

/***/ "./src/shared/shader/point/simple-point-shader.ts":
/*!********************************************************!*\
  !*** ./src/shared/shader/point/simple-point-shader.ts ***!
  \********************************************************/
/*! exports provided: SimplePointShader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SimplePointShader", function() { return SimplePointShader; });
/* harmony import */ var _simple_point_vert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./simple-point.vert */ "./src/shared/shader/point/simple-point.vert");
/* harmony import */ var _simple_point_vert__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_simple_point_vert__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _simple_point_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./simple-point.frag */ "./src/shared/shader/point/simple-point.frag");
/* harmony import */ var _simple_point_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_simple_point_frag__WEBPACK_IMPORTED_MODULE_1__);


class SimplePointShader {
    constructor(interpolation = 1.8) {
        this.interpolation = interpolation;
        this.vertexSource = _simple_point_vert__WEBPACK_IMPORTED_MODULE_0___default.a;
        this.fragmentSource = _simple_point_frag__WEBPACK_IMPORTED_MODULE_1___default.a;
    }
    configureAttributes(gl, program) {
        const position = gl.getAttribLocation(program, 'a_position');
        const size = gl.getAttribLocation(program, 'a_size');
        const color = gl.getAttribLocation(program, 'a_color');
        const vertexSize = 7 * Float32Array.BYTES_PER_ELEMENT;
        gl.vertexAttribPointer(position, 2, gl.FLOAT, false, vertexSize, 0);
        gl.vertexAttribPointer(size, 1, gl.FLOAT, false, vertexSize, 2 * Float32Array.BYTES_PER_ELEMENT);
        gl.vertexAttribPointer(color, 4, gl.FLOAT, false, vertexSize, 3 * Float32Array.BYTES_PER_ELEMENT);
        gl.enableVertexAttribArray(position);
        gl.enableVertexAttribArray(size);
        gl.enableVertexAttribArray(color);
        return () => {
            gl.disableVertexAttribArray(position);
            gl.disableVertexAttribArray(size);
            gl.disableVertexAttribArray(color);
        };
    }
    setUniforms(gl, program, matrix) {
        gl.uniformMatrix4fv(gl.getUniformLocation(program, 'u_matrix'), false, matrix);
        gl.uniform1f(gl.getUniformLocation(program, 'u_interpolation'), this.interpolation);
    }
    getArrayBufferElementsPerVertex() {
        return 7;
    }
    getPrimitiveType(gl) {
        return gl.POINTS;
    }
}


/***/ }),

/***/ "./src/shared/shader/point/simple-point.frag":
/*!***************************************************!*\
  !*** ./src/shared/shader/point/simple-point.frag ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision mediump float;\r\n\r\nuniform float u_interpolation;\r\n\r\nvarying float v_size;\r\nvarying vec4 v_color;\r\nvarying float v_halfSize;\r\n\r\nvoid main() {\r\n    float dist = v_size * distance(gl_PointCoord, vec2(0.5, 0.5));\r\n    float x = dist - v_halfSize;\r\n    float m = smoothstep(-u_interpolation, 0.0, x);\r\n    gl_FragColor = mix(v_color, vec4(v_color.rgb, 0.0), m);\r\n}\r\n"

/***/ }),

/***/ "./src/shared/shader/point/simple-point.vert":
/*!***************************************************!*\
  !*** ./src/shared/shader/point/simple-point.vert ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision mediump float;\r\n\r\nuniform mat4 u_matrix;\r\n\r\nattribute vec2 a_position;\r\nattribute float a_size;\r\nattribute vec4 a_color;\r\n\r\nvarying float v_size;\r\nvarying vec4 v_color;\r\nvarying float v_halfSize;\r\n\r\nvoid main() {\r\n    v_size = a_size;\r\n    v_color = a_color;\r\n    v_halfSize = 0.5*a_size;\r\n\r\n    gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\r\n    gl_PointSize = a_size;\r\n}\r\n"

/***/ }),

/***/ "./src/shared/shader/polygon/fancy-polygon-shader.ts":
/*!***********************************************************!*\
  !*** ./src/shared/shader/polygon/fancy-polygon-shader.ts ***!
  \***********************************************************/
/*! exports provided: FancyPolygonShader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FancyPolygonShader", function() { return FancyPolygonShader; });
/* harmony import */ var _fancy_polygon_vert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fancy-polygon.vert */ "./src/shared/shader/polygon/fancy-polygon.vert");
/* harmony import */ var _fancy_polygon_vert__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_fancy_polygon_vert__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _fancy_polygon_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fancy-polygon.frag */ "./src/shared/shader/polygon/fancy-polygon.frag");
/* harmony import */ var _fancy_polygon_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_fancy_polygon_frag__WEBPACK_IMPORTED_MODULE_1__);


class FancyPolygonShader {
    constructor(interpolation = 1.8) {
        this.interpolation = interpolation;
        this.vertexSource = _fancy_polygon_vert__WEBPACK_IMPORTED_MODULE_0___default.a;
        this.fragmentSource = _fancy_polygon_frag__WEBPACK_IMPORTED_MODULE_1___default.a;
    }
    configureAttributes(gl, program) {
        const previousPosition = gl.getAttribLocation(program, 'a_previousPosition');
        const currentPosition = gl.getAttribLocation(program, 'a_currentPosition');
        const nextPosition = gl.getAttribLocation(program, 'a_nextPosition');
        const outlineSize = gl.getAttribLocation(program, 'a_outlineSize');
        const offset = gl.getAttribLocation(program, 'a_offset');
        const color = gl.getAttribLocation(program, 'a_color');
        const outlineColor = gl.getAttribLocation(program, 'a_outlineColor');
        const vertexSize = 16 * Float32Array.BYTES_PER_ELEMENT;
        gl.vertexAttribPointer(previousPosition, 2, gl.FLOAT, false, vertexSize, 0);
        gl.vertexAttribPointer(currentPosition, 2, gl.FLOAT, false, vertexSize, 2 * Float32Array.BYTES_PER_ELEMENT);
        gl.vertexAttribPointer(nextPosition, 2, gl.FLOAT, false, vertexSize, 4 * Float32Array.BYTES_PER_ELEMENT);
        gl.vertexAttribPointer(outlineSize, 1, gl.FLOAT, false, vertexSize, 6 * Float32Array.BYTES_PER_ELEMENT);
        gl.vertexAttribPointer(offset, 1, gl.FLOAT, false, vertexSize, 7 * Float32Array.BYTES_PER_ELEMENT);
        gl.vertexAttribPointer(color, 4, gl.FLOAT, false, vertexSize, 8 * Float32Array.BYTES_PER_ELEMENT);
        gl.vertexAttribPointer(outlineColor, 4, gl.FLOAT, false, vertexSize, 12 * Float32Array.BYTES_PER_ELEMENT);
        gl.enableVertexAttribArray(previousPosition);
        gl.enableVertexAttribArray(currentPosition);
        gl.enableVertexAttribArray(nextPosition);
        gl.enableVertexAttribArray(outlineSize);
        gl.enableVertexAttribArray(offset);
        gl.enableVertexAttribArray(color);
        gl.enableVertexAttribArray(outlineColor);
        return () => {
            gl.disableVertexAttribArray(previousPosition);
            gl.disableVertexAttribArray(currentPosition);
            gl.disableVertexAttribArray(nextPosition);
            gl.disableVertexAttribArray(outlineSize);
            gl.disableVertexAttribArray(offset);
            gl.disableVertexAttribArray(color);
            gl.disableVertexAttribArray(outlineColor);
        };
    }
    setUniforms(gl, program, matrix) {
        const viewport = gl.getParameter(gl.VIEWPORT);
        gl.uniformMatrix4fv(gl.getUniformLocation(program, 'u_matrix'), false, matrix);
        gl.uniform2f(gl.getUniformLocation(program, 'u_viewPortSize'), viewport[2], viewport[3]);
        gl.uniform1f(gl.getUniformLocation(program, 'u_interpolation'), this.interpolation);
    }
    getArrayBufferElementsPerVertex() {
        return 16;
    }
    getPrimitiveType(gl) {
        return gl.TRIANGLES;
    }
}


/***/ }),

/***/ "./src/shared/shader/polygon/fancy-polygon.frag":
/*!******************************************************!*\
  !*** ./src/shared/shader/polygon/fancy-polygon.frag ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision mediump float;\r\n\r\nuniform float u_interpolation;\r\n\r\nvarying vec4 v_color;\r\nvarying vec4 v_outlineColor;\r\nvarying float v_size;\r\nvarying float v_distance;\r\n\r\nvoid main() {\r\n    bool branch = v_distance < u_interpolation;\r\n    float x = branch ? v_distance : v_size - v_distance;\r\n    vec4 color1 = branch ? v_color : vec4(v_outlineColor.rgb, 0.0);\r\n    vec4 color2 = branch ? v_outlineColor : v_outlineColor;\r\n    float m = smoothstep(0.0, u_interpolation, x);\r\n    gl_FragColor = mix(color1, color2, m);\r\n}\r\n"

/***/ }),

/***/ "./src/shared/shader/polygon/fancy-polygon.vert":
/*!******************************************************!*\
  !*** ./src/shared/shader/polygon/fancy-polygon.vert ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision mediump float;\r\n\r\nuniform mat4 u_matrix;\r\nuniform vec2 u_viewPortSize;\r\nuniform float u_interpolation;\r\n\r\nattribute vec2 a_previousPosition;\r\nattribute vec2 a_currentPosition;\r\nattribute vec2 a_nextPosition;\r\nattribute float a_outlineSize;\r\nattribute float a_offset;\r\nattribute vec4 a_color;\r\nattribute vec4 a_outlineColor;\r\n\r\nvarying vec4 v_color;\r\nvarying vec4 v_outlineColor;\r\nvarying float v_size;\r\nvarying float v_distance;\r\n\r\nvoid main() {\r\n    v_color = a_color;\r\n    v_outlineColor = a_outlineColor;\r\n    v_size = a_outlineSize + u_interpolation;\r\n    v_distance = a_offset * v_size;\r\n\r\n    vec4 previousProjected = u_matrix * vec4(a_previousPosition, 0.0, 1.0);\r\n    vec4 currentProjected = u_matrix * vec4(a_currentPosition, 0.0, 1.0);\r\n    vec4 nextProjected = u_matrix * vec4(a_nextPosition, 0.0, 1.0);\r\n\r\n    vec2 previousScreen = previousProjected.xy / previousProjected.w * u_viewPortSize;\r\n    vec2 currentScreen = currentProjected.xy / currentProjected.w * u_viewPortSize;\r\n    vec2 nextScreen = nextProjected.xy / nextProjected.w * u_viewPortSize;\r\n\r\n    vec2 dirA = normalize(currentScreen - previousScreen);\r\n    vec2 dirB = normalize(nextScreen - currentScreen);\r\n    vec2 tangent = normalize(dirA + dirB);\r\n    vec2 perp = vec2(-dirA.y, dirA.x);\r\n\r\n    vec2 normal = vec2(-tangent.y, tangent.x);\r\n    vec2 offset = (2.0 * v_distance / max(dot(normal, perp), 0.1) * normal) / u_viewPortSize;\r\n\r\n    gl_Position = vec4(currentProjected.xy / max(currentProjected.w, 0.0001) - offset, 0.0, 1.0);\r\n}\r\n"

/***/ }),

/***/ "./src/shared/shader/polygon/simple-polygon-shader.ts":
/*!************************************************************!*\
  !*** ./src/shared/shader/polygon/simple-polygon-shader.ts ***!
  \************************************************************/
/*! exports provided: SimplePolygonShader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SimplePolygonShader", function() { return SimplePolygonShader; });
/* harmony import */ var _default_default_shader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../default/default-shader */ "./src/shared/shader/default/default-shader.ts");

class SimplePolygonShader extends _default_default_shader__WEBPACK_IMPORTED_MODULE_0__["DefaultShader"] {
    getPrimitiveType(gl) {
        return gl.TRIANGLES;
    }
}


/***/ }),

/***/ "./src/shared/shader/shader.ts":
/*!*************************************!*\
  !*** ./src/shared/shader/shader.ts ***!
  \*************************************/
/*! exports provided: createShaderProgram */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createShaderProgram", function() { return createShaderProgram; });
function createShaderProgram(gl, vertexSource, fragmentSource) {
    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
    if (vertexShader == null) {
        throw Error('Vertex shader is NULL.');
    }
    gl.shaderSource(vertexShader, vertexSource);
    gl.compileShader(vertexShader);
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        throw Error('ERROR compiling vertex shader! ' + gl.getShaderInfoLog(vertexShader));
    }
    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    if (fragmentShader == null) {
        throw Error('Fragment shader is NULL.');
    }
    gl.shaderSource(fragmentShader, fragmentSource);
    gl.compileShader(fragmentShader);
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        throw Error('ERROR compiling fragment shader! ' + gl.getShaderInfoLog(fragmentShader));
    }
    const program = gl.createProgram();
    if (program == null) {
        throw Error('Program is NULL.');
    }
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        throw Error('ERROR linking program! ' + gl.getProgramInfoLog(program));
    }
    gl.validateProgram(program);
    if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {
        throw Error('ERROR validating program! ' + gl.getProgramInfoLog(program));
    }
    return program;
}


/***/ }),

/***/ "./src/shared/shader/texture-drawer/texture-drawer.frag":
/*!**************************************************************!*\
  !*** ./src/shared/shader/texture-drawer/texture-drawer.frag ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision mediump float;\r\n\r\nuniform sampler2D u_sampler;\r\n\r\nvarying vec2 v_textureCoordinate;\r\n\r\nvoid main() {\r\n    gl_FragColor = texture2D(u_sampler, v_textureCoordinate);\r\n}\r\n"

/***/ }),

/***/ "./src/shared/shader/texture-drawer/texture-drawer.ts":
/*!************************************************************!*\
  !*** ./src/shared/shader/texture-drawer/texture-drawer.ts ***!
  \************************************************************/
/*! exports provided: TextureDrawer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextureDrawer", function() { return TextureDrawer; });
/* harmony import */ var _shader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shader */ "./src/shared/shader/shader.ts");
/* harmony import */ var _texture_drawer_vert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./texture-drawer.vert */ "./src/shared/shader/texture-drawer/texture-drawer.vert");
/* harmony import */ var _texture_drawer_vert__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_texture_drawer_vert__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _texture_drawer_frag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./texture-drawer.frag */ "./src/shared/shader/texture-drawer/texture-drawer.frag");
/* harmony import */ var _texture_drawer_frag__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_texture_drawer_frag__WEBPACK_IMPORTED_MODULE_2__);



class TextureDrawer {
    constructor() {
        this.program = null;
        this.vertexBuffer = null;
    }
    initialise(gl) {
        this.program = Object(_shader__WEBPACK_IMPORTED_MODULE_0__["createShaderProgram"])(gl, _texture_drawer_vert__WEBPACK_IMPORTED_MODULE_1___default.a, _texture_drawer_frag__WEBPACK_IMPORTED_MODULE_2___default.a);
        this.vertexBuffer = gl.createBuffer();
    }
    dispose(gl) {
        gl.deleteBuffer(this.vertexBuffer);
        gl.deleteProgram(this.program);
    }
    draw(gl, texture, matrix, x, y, w, h) {
        if (this.program == null || this.vertexBuffer == null) {
            throw Error('TextureDrawer can not draw before it is initialised.');
        }
        gl.enable(gl.BLEND);
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        const x1 = x, x2 = x + w, y1 = y, y2 = y + h;
        const bufferArray = new Float32Array([
            x1, y1, 0, 1,
            x2, y1, 1, 1,
            x2, y2, 1, 0,
            x1, y1, 0, 1,
            x1, y2, 0, 0,
            x2, y2, 1, 0
        ]);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.useProgram(this.program);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        const cleanUpAttributes = configureAttributes(gl, this.program);
        gl.bufferData(gl.ARRAY_BUFFER, bufferArray, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        setUniforms(gl, this.program, matrix);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
        gl.bindTexture(gl.TEXTURE_2D, null);
        cleanUpAttributes();
    }
}
function configureAttributes(gl, program) {
    const position = gl.getAttribLocation(program, 'a_position');
    const textureCoordinate = gl.getAttribLocation(program, 'a_textureCoordinate');
    const vertexSize = 4 * Float32Array.BYTES_PER_ELEMENT;
    gl.vertexAttribPointer(position, 2, gl.FLOAT, false, vertexSize, 0);
    gl.vertexAttribPointer(textureCoordinate, 2, gl.FLOAT, false, vertexSize, 2 * Float32Array.BYTES_PER_ELEMENT);
    gl.enableVertexAttribArray(position);
    gl.enableVertexAttribArray(textureCoordinate);
    return () => {
        gl.disableVertexAttribArray(position);
        gl.disableVertexAttribArray(textureCoordinate);
    };
}
function setUniforms(gl, program, matrix) {
    gl.uniformMatrix4fv(gl.getUniformLocation(program, 'u_matrix'), false, matrix);
    gl.uniform1i(gl.getUniformLocation(program, 'u_sampler'), 0);
}


/***/ }),

/***/ "./src/shared/shader/texture-drawer/texture-drawer.vert":
/*!**************************************************************!*\
  !*** ./src/shared/shader/texture-drawer/texture-drawer.vert ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision mediump float;\r\n\r\nuniform mat4 u_matrix;\r\nuniform sampler2D u_sampler;\r\n\r\nattribute vec2 a_position;\r\nattribute vec2 a_textureCoordinate;\r\n\r\nvarying vec2 v_textureCoordinate;\r\n\r\nvoid main() {\r\n    v_textureCoordinate = a_textureCoordinate;\r\n    gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\r\n}\r\n"

/***/ }),

/***/ "./src/shared/styles.ts":
/*!******************************!*\
  !*** ./src/shared/styles.ts ***!
  \******************************/
/*! exports provided: defaultPointStyle, defaultLineStyle, defaultPolygonStyle, resolveStyle, resolvePointStyle, resolveLineStyle, resolvePolygonStyle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultPointStyle", function() { return defaultPointStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultLineStyle", function() { return defaultLineStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultPolygonStyle", function() { return defaultPolygonStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolveStyle", function() { return resolveStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolvePointStyle", function() { return resolvePointStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolveLineStyle", function() { return resolveLineStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolvePolygonStyle", function() { return resolvePolygonStyle; });
const defaultPointStyle = {
    size: 10,
    color: { r: 0, g: 0, b: 1 },
    opacity: 0.8,
    outlineSize: 0,
    outlineColor: { r: 0, g: 0, b: 0 },
    outlineOpacity: 0.8
};
const defaultLineStyle = {
    size: 5,
    color: { r: 0, g: 0, b: 1 },
    opacity: 0.8,
    outlineSize: 0,
    outlineColor: { r: 0, g: 0, b: 0 },
    outlineOpacity: 0.8
};
const defaultPolygonStyle = {
    color: { r: 0, g: 0, b: 1 },
    opacity: 0.5,
    outlineSize: 0,
    outlineColor: { r: 0, g: 0, b: 0 },
    outlineOpacity: 0.8
};
function resolveStyle(output, feature, styleOption, defaultStyle) {
    // @ts-ignore
    Object.keys(defaultStyle).forEach(key => output[key] = defaultStyle[key]);
    if (styleOption != null) {
        const partialStyle = typeof styleOption === 'object' ? styleOption : styleOption(feature);
        // @ts-ignore
        Object.keys(partialStyle).forEach(key => output[key] = partialStyle[key]);
    }
}
function resolvePointStyle(output, feature, styleOption) {
    resolveStyle(output, feature, styleOption, defaultPointStyle);
    if (output.outlineSize <= 0) {
        output.outlineColor = output.color;
        output.outlineOpacity = output.opacity;
    }
}
function resolveLineStyle(output, feature, styleOption) {
    resolveStyle(output, feature, styleOption, defaultLineStyle);
    if (output.outlineSize <= 0) {
        output.outlineColor = output.color;
        output.outlineOpacity = output.opacity;
    }
}
function resolvePolygonStyle(output, feature, styleOption) {
    resolveStyle(output, feature, styleOption, defaultPolygonStyle);
    if (output.outlineSize <= 0) {
        output.outlineColor = output.color;
        output.outlineOpacity = output.opacity;
    }
}


/***/ }),

/***/ "./src/shared/tile/tile-generator.ts":
/*!*******************************************!*\
  !*** ./src/shared/tile/tile-generator.ts ***!
  \*******************************************/
/*! exports provided: TileGenerator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TileGenerator", function() { return TileGenerator; });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "gl-matrix");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(gl_matrix__WEBPACK_IMPORTED_MODULE_0__);

class TileGenerator {
    constructor(renderer) {
        this.renderer = renderer;
        this.frameBuffer = null;
        this.matrix = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create();
    }
    initialise(map, gl) {
        this.frameBuffer = gl.createFramebuffer();
        this.renderer.initialise(map, gl);
    }
    dispose(map, gl) {
        this.renderer.dispose(map, gl);
        gl.deleteFramebuffer(this.frameBuffer);
    }
    generateTile(gl, texture, textureWidth, textureHeight, x, y, zoom) {
        if (this.frameBuffer == null) {
            throw Error('TileGenerator can not generate tiles before it is initialised.');
        }
        const oldFrameBuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
        const oldViewport = gl.getParameter(gl.VIEWPORT);
        this.setMatrixValue(x, y, zoom);
        this.renderer.prerender(gl, this.matrix);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
        gl.viewport(0, 0, textureWidth, textureHeight);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        this.renderer.render(gl, this.matrix);
        gl.viewport(oldViewport[0], oldViewport[1], oldViewport[2], oldViewport[3]);
        gl.bindFramebuffer(gl.FRAMEBUFFER, oldFrameBuffer);
        gl.bindTexture(gl.TEXTURE_2D, null);
    }
    setMatrixValue(x, y, zoom) {
        const viewportSize = Math.pow(2, -zoom);
        const viewportX = x * viewportSize;
        const viewportY = y * viewportSize;
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].ortho(this.matrix, viewportX, viewportX + viewportSize, viewportY + viewportSize, viewportY, -1, 1);
    }
}


/***/ }),

/***/ "./src/shared/tile/tile-manager.ts":
/*!*****************************************!*\
  !*** ./src/shared/tile/tile-manager.ts ***!
  \*****************************************/
/*! exports provided: TileManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TileManager", function() { return TileManager; });
/* harmony import */ var _geometry_functions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry-functions */ "./src/shared/geometry-functions.ts");

class TileManager {
    constructor(generator, numberOfTiles, tileWidth, tileHeight) {
        this.generator = generator;
        this.numberOfTiles = numberOfTiles;
        this.tileWidth = tileWidth;
        this.tileHeight = tileHeight;
        this.tiles = null;
    }
    markAllTilesOutdated() {
        if (this.tiles == null) {
            return;
        }
        for (const tile of this.tiles) {
            tile.zoom = -1;
            tile.age = Number.MAX_VALUE / 2;
        }
    }
    markOutdatedTiles(bounds) {
        if (this.tiles == null) {
            return;
        }
        for (const tile of this.tiles) {
            if (isTileInDataBounds(tile.x, tile.y, tile.zoom, bounds)) {
                tile.zoom = -1;
                tile.age = Number.MAX_VALUE / 2;
            }
        }
    }
    initialise(map, gl) {
        this.generator.initialise(map, gl);
        const tiles = [];
        for (let i = 0; i < this.numberOfTiles; i++) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.tileWidth, this.tileHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            tiles.push({
                x: 0,
                y: 0,
                zoom: -1,
                age: Number.MAX_VALUE / 2,
                texture: texture
            });
        }
        gl.bindTexture(gl.TEXTURE_2D, null);
        this.tiles = tiles;
    }
    dispose(map, gl) {
        if (this.tiles != null) {
            this.tiles.forEach(tile => gl.deleteTexture(tile.texture));
        }
        this.tiles = null;
        this.generator.dispose(map, gl);
    }
    getTileTexture(gl, x, y, zoom, dataBounds) {
        const tiles = this.tiles;
        if (tiles == null) {
            throw Error('TileManager can not get a tile texture before it is initialised.');
        }
        if (!isTileInDataBounds(x, y, zoom, dataBounds)) {
            return null;
        }
        const foundTile = tiles.find(t => t.x === x && t.y === y && t.zoom === zoom);
        if (foundTile != null) {
            foundTile.age = 0;
            return foundTile.texture;
        }
        let leastUsedTile = tiles[0];
        for (const tile of tiles) {
            if (tile.age > leastUsedTile.age) {
                leastUsedTile = tile;
            }
        }
        leastUsedTile.x = x;
        leastUsedTile.y = y;
        leastUsedTile.zoom = zoom;
        leastUsedTile.age = 0;
        this.generator.generateTile(gl, leastUsedTile.texture, this.tileWidth, this.tileHeight, x, y, zoom);
        return leastUsedTile.texture;
    }
    incrementAge() {
        if (this.tiles == null) {
            throw Error('TileManager can not increment age before it is initialised.');
        }
        for (const tile of this.tiles) {
            tile.age++;
        }
    }
}
function isTileInDataBounds(x, y, zoom, bounds) {
    if (bounds == null) {
        return true;
    }
    const size = Math.pow(2, -zoom);
    const tileMinX = x * size;
    const tileMinY = y * size;
    const tileMaxX = tileMinX + size;
    const tileMaxY = tileMinY + size;
    const minX = Object(_geometry_functions__WEBPACK_IMPORTED_MODULE_0__["transformX"])(bounds.minX);
    const minY = Object(_geometry_functions__WEBPACK_IMPORTED_MODULE_0__["transformY"])(bounds.maxY);
    const maxX = Object(_geometry_functions__WEBPACK_IMPORTED_MODULE_0__["transformX"])(bounds.maxX);
    const maxY = Object(_geometry_functions__WEBPACK_IMPORTED_MODULE_0__["transformY"])(bounds.minY);
    return tileMinX <= maxX &&
        tileMaxX >= minX &&
        tileMinY <= maxY &&
        tileMaxY >= minY;
}


/***/ }),

/***/ "./src/shared/tile/tile-renderer.ts":
/*!******************************************!*\
  !*** ./src/shared/tile/tile-renderer.ts ***!
  \******************************************/
/*! exports provided: TileRenderer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TileRenderer", function() { return TileRenderer; });
/* harmony import */ var _tile_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tile-manager */ "./src/shared/tile/tile-manager.ts");
/* harmony import */ var _shader_texture_drawer_texture_drawer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shader/texture-drawer/texture-drawer */ "./src/shared/shader/texture-drawer/texture-drawer.ts");
/* harmony import */ var _tile_generator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tile-generator */ "./src/shared/tile/tile-generator.ts");
/* harmony import */ var _geometry_functions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geometry-functions */ "./src/shared/geometry-functions.ts");




class TileRenderer {
    constructor(renderer, options) {
        this.renderer = renderer;
        this.textureDrawer = new _shader_texture_drawer_texture_drawer__WEBPACK_IMPORTED_MODULE_1__["TextureDrawer"]();
        this.map = null;
        this.viewBounds = {
            minX: Infinity,
            minY: Infinity,
            maxX: -Infinity,
            maxY: -Infinity
        };
        const numberOfTiles = options.numberOfTiles != null ? options.numberOfTiles : 16;
        this.tileWidth = options.tileWidth != null ? options.tileWidth : 2048;
        this.tileHeight = options.tileHeight != null ? options.tileHeight : 2048;
        this.manager = new _tile_manager__WEBPACK_IMPORTED_MODULE_0__["TileManager"](new _tile_generator__WEBPACK_IMPORTED_MODULE_2__["TileGenerator"](renderer), numberOfTiles, this.tileWidth, this.tileHeight);
    }
    markAllTilesOutdated() {
        this.manager.markAllTilesOutdated();
    }
    markOutdatedTiles(bounds) {
        this.manager.markOutdatedTiles(bounds);
    }
    initialise(map, gl) {
        this.manager.initialise(map, gl);
        this.textureDrawer.initialise(gl);
        this.map = map;
    }
    dispose(map, gl) {
        this.map = null;
        this.textureDrawer.dispose(gl);
        this.manager.dispose(map, gl);
    }
    render(gl, matrix, dataBounds) {
        if (this.map == null) {
            throw Error('TiledRenderer can not render without being initialised.');
        }
        const viewportArray = gl.getParameter(gl.VIEWPORT);
        const viewport = {
            x: viewportArray[0],
            y: viewportArray[1],
            w: viewportArray[2],
            h: viewportArray[3]
        };
        const bounds = this.viewBounds;
        Object(_geometry_functions__WEBPACK_IMPORTED_MODULE_3__["findViewBounds"])(bounds, this.map);
        const equationFactor = Math.min(this.tileWidth * (bounds.maxX - bounds.minX) / viewport.w, this.tileHeight * (bounds.maxY - bounds.minY) / viewport.h);
        const zoom = Math.ceil(-Math.log2(equationFactor));
        const size = Math.pow(2, -zoom);
        for (let x = Math.floor(bounds.minX / size); x * size < bounds.maxX; x++) {
            for (let y = Math.floor(bounds.minY / size); y * size < bounds.maxY; y++) {
                const texture = this.manager.getTileTexture(gl, x, y, zoom, dataBounds);
                if (texture != null) {
                    this.drawTile(gl, texture, matrix, x, y, zoom);
                }
            }
        }
        this.manager.incrementAge();
    }
    drawTile(gl, texture, matrix, x, y, zoom) {
        const size = Math.pow(2, -zoom);
        this.textureDrawer.draw(gl, texture, matrix, x * size, y * size, size, size);
    }
}


/***/ }),

/***/ "./src/shared/visibility.ts":
/*!**********************************!*\
  !*** ./src/shared/visibility.ts ***!
  \**********************************/
/*! exports provided: resolveVisibility */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolveVisibility", function() { return resolveVisibility; });
function resolveVisibility(visibility, map) {
    if (visibility == null) {
        return true;
    }
    else if (typeof visibility === 'boolean') {
        return visibility;
    }
    else if (map != null) {
        return visibility(map);
    }
    else {
        return true;
    }
}


/***/ }),

/***/ "./src/static-data/click-provider/kd-bush-click-provider.ts":
/*!******************************************************************!*\
  !*** ./src/static-data/click-provider/kd-bush-click-provider.ts ***!
  \******************************************************************/
/*! exports provided: KdBushClickProvider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KdBushClickProvider", function() { return KdBushClickProvider; });
/* harmony import */ var _shared_visibility__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/visibility */ "./src/shared/visibility.ts");
/* harmony import */ var _shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/geometry-functions */ "./src/shared/geometry-functions.ts");
/* harmony import */ var kdbush__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! kdbush */ "kdbush");
/* harmony import */ var kdbush__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(kdbush__WEBPACK_IMPORTED_MODULE_2__);



class KdBushClickProvider {
    constructor(onClick, clickSize) {
        this.onClick = onClick;
        this.clickSize = clickSize;
        this.map = null;
        this.data = null;
        this.index = null;
        this.visibility = true;
        this.clickHandler = (e) => {
            if (this.map == null || this.data == null || this.index == null) {
                return;
            }
            if (!Object(_shared_visibility__WEBPACK_IMPORTED_MODULE_0__["resolveVisibility"])(this.visibility, this.map)) {
                return;
            }
            const bounds = this.map.getBounds();
            const canvas = this.map.getCanvas();
            const clickSize = this.clickSize != null ? this.clickSize : 16;
            const x = e.lngLat.lng;
            const y = e.lngLat.lat;
            const w = clickSize * (bounds.getEast() - bounds.getWest()) / canvas.width;
            const h = clickSize * (bounds.getNorth() - bounds.getSouth()) / canvas.height;
            const indices = this.index.range(x - 0.5 * w, y - 0.5 * h, x + 0.5 * w, y + 0.5 * h);
            if (indices.length === 0) {
                return;
            }
            let closestResultIndex = indices[0];
            let minDistanceSqr = Infinity;
            for (const i of indices) {
                const result = this.data[i];
                const distanceSqr = Object(_shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__["pointToPointDistanceSqr"])(x, y, result.x, result.y);
                if (distanceSqr < minDistanceSqr) {
                    closestResultIndex = i;
                    minDistanceSqr = distanceSqr;
                }
            }
            const size = Math.max(w, h);
            const clickDistanceSqr = 0.25 * (size * size);
            if (minDistanceSqr <= clickDistanceSqr) {
                this.onClick(this.data[closestResultIndex].feature, e);
            }
        };
    }
    setData(data) {
        const packedData = [];
        for (const feature of data.features) {
            if (feature.geometry.type === 'Point') {
                const coords = feature.geometry.coordinates;
                const packed = {
                    feature: feature,
                    x: coords[0],
                    y: coords[1]
                };
                packedData.push(packed);
            }
            else if (feature.geometry.type === 'MultiPoint') {
                const multiPoint = feature.geometry;
                for (const coords of multiPoint.coordinates) {
                    const packed = {
                        feature: feature,
                        x: coords[0],
                        y: coords[1]
                    };
                    packedData.push(packed);
                }
            }
        }
        this.data = packedData;
        this.index = new kdbush__WEBPACK_IMPORTED_MODULE_2___default.a(packedData, p => p.x, p => p.y, 64, Float64Array);
    }
    clearData() {
        this.index = null;
        this.data = null;
    }
    initialise(map) {
        this.map = map;
        map.on('click', this.clickHandler);
    }
    dispose(map) {
        this.map = null;
        map.off('click', this.clickHandler);
    }
    setVisibility(visibility) {
        this.visibility = visibility;
    }
}


/***/ }),

/***/ "./src/static-data/click-provider/r-bush-click-provider.ts":
/*!*****************************************************************!*\
  !*** ./src/static-data/click-provider/r-bush-click-provider.ts ***!
  \*****************************************************************/
/*! exports provided: RBushClickProvider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RBushClickProvider", function() { return RBushClickProvider; });
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rbush */ "rbush");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rbush__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/geometry-functions */ "./src/shared/geometry-functions.ts");
/* harmony import */ var _shared_visibility__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/visibility */ "./src/shared/visibility.ts");



class RBushClickProvider {
    constructor(resultsHandler, clickSize) {
        this.resultsHandler = resultsHandler;
        this.clickSize = clickSize;
        this.map = null;
        this.tree = null;
        this.visibility = true;
        this.clickHandler = (e) => {
            if (this.map == null || this.tree == null) {
                return;
            }
            if (!Object(_shared_visibility__WEBPACK_IMPORTED_MODULE_2__["resolveVisibility"])(this.visibility, this.map)) {
                return;
            }
            const bounds = this.map.getBounds();
            const canvas = this.map.getCanvas();
            const clickSize = this.clickSize != null ? this.clickSize : 16;
            const x = e.lngLat.lng;
            const y = e.lngLat.lat;
            const w = clickSize * (bounds.getEast() - bounds.getWest()) / canvas.width;
            const h = clickSize * (bounds.getNorth() - bounds.getSouth()) / canvas.height;
            const results = this.tree.search({
                minX: x - 0.5 * w,
                minY: y - 0.5 * h,
                maxX: x + 0.5 * w,
                maxY: y + 0.5 * h
            });
            this.resultsHandler(x, y, Math.max(w, h), results, e);
        };
    }
    setData(data) {
        const packedData = data.features.map((feature, index) => Object(_shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__["packFeature"])(feature, index));
        this.tree = new rbush__WEBPACK_IMPORTED_MODULE_0___default.a();
        this.tree.load(packedData);
    }
    clearData() {
        this.tree = null;
    }
    initialise(map) {
        this.map = map;
        map.on('click', this.clickHandler);
    }
    dispose(map) {
        this.map = null;
        map.off('click', this.clickHandler);
    }
    setVisibility(visibility) {
        this.visibility = visibility;
    }
}


/***/ }),

/***/ "./src/static-data/layer-preset/line-layer.ts":
/*!****************************************************!*\
  !*** ./src/static-data/layer-preset/line-layer.ts ***!
  \****************************************************/
/*! exports provided: lineLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineLayer", function() { return lineLayer; });
/* harmony import */ var _renderer_preset_line_renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../renderer-preset/line-renderer */ "./src/static-data/renderer-preset/line-renderer.ts");
/* harmony import */ var _static_data_layer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../static-data-layer */ "./src/static-data/static-data-layer.ts");
/* harmony import */ var _shared_click_handler_line_click_handler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/click-handler/line-click-handler */ "./src/shared/click-handler/line-click-handler.ts");
/* harmony import */ var _click_provider_r_bush_click_provider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../click-provider/r-bush-click-provider */ "./src/static-data/click-provider/r-bush-click-provider.ts");




function lineLayer(options) {
    return new _static_data_layer__WEBPACK_IMPORTED_MODULE_1__["StaticDataLayer"]({
        id: options.id,
        renderer: Object(_renderer_preset_line_renderer__WEBPACK_IMPORTED_MODULE_0__["lineRenderer"])(options),
        clickProvider: options.onClick != null ?
            new _click_provider_r_bush_click_provider__WEBPACK_IMPORTED_MODULE_3__["RBushClickProvider"](Object(_shared_click_handler_line_click_handler__WEBPACK_IMPORTED_MODULE_2__["lineToResultsClickHandler"])(options.onClick), options.clickSize) : undefined
    });
}


/***/ }),

/***/ "./src/static-data/layer-preset/point-layer.ts":
/*!*****************************************************!*\
  !*** ./src/static-data/layer-preset/point-layer.ts ***!
  \*****************************************************/
/*! exports provided: pointLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointLayer", function() { return pointLayer; });
/* harmony import */ var _renderer_preset_point_renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../renderer-preset/point-renderer */ "./src/static-data/renderer-preset/point-renderer.ts");
/* harmony import */ var _static_data_layer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../static-data-layer */ "./src/static-data/static-data-layer.ts");
/* harmony import */ var _click_provider_kd_bush_click_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../click-provider/kd-bush-click-provider */ "./src/static-data/click-provider/kd-bush-click-provider.ts");



function pointLayer(options) {
    return new _static_data_layer__WEBPACK_IMPORTED_MODULE_1__["StaticDataLayer"]({
        id: options.id,
        renderer: Object(_renderer_preset_point_renderer__WEBPACK_IMPORTED_MODULE_0__["pointRenderer"])(options),
        clickProvider: options.onClick != null ?
            new _click_provider_kd_bush_click_provider__WEBPACK_IMPORTED_MODULE_2__["KdBushClickProvider"](options.onClick, options.clickSize) : undefined
    });
}


/***/ }),

/***/ "./src/static-data/layer-preset/polygon-layer.ts":
/*!*******************************************************!*\
  !*** ./src/static-data/layer-preset/polygon-layer.ts ***!
  \*******************************************************/
/*! exports provided: polygonLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polygonLayer", function() { return polygonLayer; });
/* harmony import */ var _renderer_preset_polygon_renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../renderer-preset/polygon-renderer */ "./src/static-data/renderer-preset/polygon-renderer.ts");
/* harmony import */ var _static_data_layer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../static-data-layer */ "./src/static-data/static-data-layer.ts");
/* harmony import */ var _shared_click_handler_polygon_click_handler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/click-handler/polygon-click-handler */ "./src/shared/click-handler/polygon-click-handler.ts");
/* harmony import */ var _click_provider_r_bush_click_provider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../click-provider/r-bush-click-provider */ "./src/static-data/click-provider/r-bush-click-provider.ts");




function polygonLayer(options) {
    return new _static_data_layer__WEBPACK_IMPORTED_MODULE_1__["StaticDataLayer"]({
        id: options.id,
        renderer: Object(_renderer_preset_polygon_renderer__WEBPACK_IMPORTED_MODULE_0__["polygonRenderer"])(options),
        clickProvider: options.onClick != null ?
            new _click_provider_r_bush_click_provider__WEBPACK_IMPORTED_MODULE_3__["RBushClickProvider"](Object(_shared_click_handler_polygon_click_handler__WEBPACK_IMPORTED_MODULE_2__["polygonToResultsClickHandler"])(options.onClick), 0) : undefined
    });
}


/***/ }),

/***/ "./src/static-data/renderer-preset/line-renderer.ts":
/*!**********************************************************!*\
  !*** ./src/static-data/renderer-preset/line-renderer.ts ***!
  \**********************************************************/
/*! exports provided: lineRenderer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineRenderer", function() { return lineRenderer; });
/* harmony import */ var _shared_shader_line_fancy_line_shader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/shader/line/fancy-line-shader */ "./src/shared/shader/line/fancy-line-shader.ts");
/* harmony import */ var _shared_shader_line_simple_line_shader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/shader/line/simple-line-shader */ "./src/shared/shader/line/simple-line-shader.ts");
/* harmony import */ var _renderer_switch_renderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../renderer/switch-renderer */ "./src/static-data/renderer/switch-renderer.ts");
/* harmony import */ var _renderer_shader_renderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../renderer/shader-renderer */ "./src/static-data/renderer/shader-renderer.ts");
/* harmony import */ var _renderer_tiled_renderer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../renderer/tiled-renderer */ "./src/static-data/renderer/tiled-renderer.ts");
/* harmony import */ var _vertex_data_mapper_simple_lines_to_shader_buffers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../vertex-data-mapper/simple-lines-to-shader-buffers */ "./src/static-data/vertex-data-mapper/simple-lines-to-shader-buffers.ts");
/* harmony import */ var _vertex_data_mapper_fancy_lines_to_shader_buffers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../vertex-data-mapper/fancy-lines-to-shader-buffers */ "./src/static-data/vertex-data-mapper/fancy-lines-to-shader-buffers.ts");







function lineRenderer(options) {
    const isSimple = options.simpleRendering != null && options.simpleRendering;
    const shader = isSimple ? new _shared_shader_line_simple_line_shader__WEBPACK_IMPORTED_MODULE_1__["SimpleLineShader"]() : new _shared_shader_line_fancy_line_shader__WEBPACK_IMPORTED_MODULE_0__["FancyLineShader"](options.interpolation);
    const dataMapper = isSimple ? _vertex_data_mapper_simple_lines_to_shader_buffers__WEBPACK_IMPORTED_MODULE_5__["simpleLinesToShaderBuffers"] : _vertex_data_mapper_fancy_lines_to_shader_buffers__WEBPACK_IMPORTED_MODULE_6__["fancyLinesToShaderBuffers"];
    const threshold = options.tileThreshold != null ? options.tileThreshold : 10000;
    return new _renderer_switch_renderer__WEBPACK_IMPORTED_MODULE_2__["SwitchRenderer"]([
        {
            renderer: new _renderer_shader_renderer__WEBPACK_IMPORTED_MODULE_3__["ShaderRenderer"](shader, dataMapper),
            condition: data => data.features.length < threshold
        },
        {
            renderer: new _renderer_tiled_renderer__WEBPACK_IMPORTED_MODULE_4__["TiledRenderer"](new _renderer_shader_renderer__WEBPACK_IMPORTED_MODULE_3__["ShaderRenderer"](shader, dataMapper), options),
            condition: data => data.features.length >= threshold
        }
    ]);
}


/***/ }),

/***/ "./src/static-data/renderer-preset/point-renderer.ts":
/*!***********************************************************!*\
  !*** ./src/static-data/renderer-preset/point-renderer.ts ***!
  \***********************************************************/
/*! exports provided: pointRenderer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointRenderer", function() { return pointRenderer; });
/* harmony import */ var _shared_shader_point_fancy_point_shader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/shader/point/fancy-point-shader */ "./src/shared/shader/point/fancy-point-shader.ts");
/* harmony import */ var _shared_shader_point_simple_point_shader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/shader/point/simple-point-shader */ "./src/shared/shader/point/simple-point-shader.ts");
/* harmony import */ var _renderer_switch_renderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../renderer/switch-renderer */ "./src/static-data/renderer/switch-renderer.ts");
/* harmony import */ var _renderer_shader_renderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../renderer/shader-renderer */ "./src/static-data/renderer/shader-renderer.ts");
/* harmony import */ var _renderer_tiled_renderer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../renderer/tiled-renderer */ "./src/static-data/renderer/tiled-renderer.ts");
/* harmony import */ var _vertex_data_mapper_simple_points_to_shader_buffers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../vertex-data-mapper/simple-points-to-shader-buffers */ "./src/static-data/vertex-data-mapper/simple-points-to-shader-buffers.ts");
/* harmony import */ var _vertex_data_mapper_fancy_points_to_shader_buffers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../vertex-data-mapper/fancy-points-to-shader-buffers */ "./src/static-data/vertex-data-mapper/fancy-points-to-shader-buffers.ts");







function pointRenderer(options) {
    const isSimple = options.simpleRendering != null && options.simpleRendering;
    const shader = isSimple ? new _shared_shader_point_simple_point_shader__WEBPACK_IMPORTED_MODULE_1__["SimplePointShader"](options.interpolation) : new _shared_shader_point_fancy_point_shader__WEBPACK_IMPORTED_MODULE_0__["FancyPointShader"](options.interpolation);
    const dataMapper = isSimple ? _vertex_data_mapper_simple_points_to_shader_buffers__WEBPACK_IMPORTED_MODULE_5__["simplePointsToShaderBuffers"] : _vertex_data_mapper_fancy_points_to_shader_buffers__WEBPACK_IMPORTED_MODULE_6__["fancyPointsToShaderBuffers"];
    const threshold = options.tileThreshold != null ? options.tileThreshold : 100000;
    return new _renderer_switch_renderer__WEBPACK_IMPORTED_MODULE_2__["SwitchRenderer"]([
        {
            renderer: new _renderer_shader_renderer__WEBPACK_IMPORTED_MODULE_3__["ShaderRenderer"](shader, dataMapper),
            condition: data => data.features.length < threshold
        },
        {
            renderer: new _renderer_tiled_renderer__WEBPACK_IMPORTED_MODULE_4__["TiledRenderer"](new _renderer_shader_renderer__WEBPACK_IMPORTED_MODULE_3__["ShaderRenderer"](shader, dataMapper), options),
            condition: data => data.features.length >= threshold
        }
    ]);
}


/***/ }),

/***/ "./src/static-data/renderer-preset/polygon-renderer.ts":
/*!*************************************************************!*\
  !*** ./src/static-data/renderer-preset/polygon-renderer.ts ***!
  \*************************************************************/
/*! exports provided: polygonRenderer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polygonRenderer", function() { return polygonRenderer; });
/* harmony import */ var _shared_shader_polygon_fancy_polygon_shader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/shader/polygon/fancy-polygon-shader */ "./src/shared/shader/polygon/fancy-polygon-shader.ts");
/* harmony import */ var _shared_shader_polygon_simple_polygon_shader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/shader/polygon/simple-polygon-shader */ "./src/shared/shader/polygon/simple-polygon-shader.ts");
/* harmony import */ var _renderer_switch_renderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../renderer/switch-renderer */ "./src/static-data/renderer/switch-renderer.ts");
/* harmony import */ var _renderer_shader_renderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../renderer/shader-renderer */ "./src/static-data/renderer/shader-renderer.ts");
/* harmony import */ var _renderer_tiled_renderer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../renderer/tiled-renderer */ "./src/static-data/renderer/tiled-renderer.ts");
/* harmony import */ var _vertex_data_mapper_simple_polygons_to_shader_buffers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../vertex-data-mapper/simple-polygons-to-shader-buffers */ "./src/static-data/vertex-data-mapper/simple-polygons-to-shader-buffers.ts");
/* harmony import */ var _vertex_data_mapper_fancy_polygons_to_shader_buffers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../vertex-data-mapper/fancy-polygons-to-shader-buffers */ "./src/static-data/vertex-data-mapper/fancy-polygons-to-shader-buffers.ts");







function polygonRenderer(options) {
    const isSimple = options.simpleRendering != null && options.simpleRendering;
    const shader = isSimple ? new _shared_shader_polygon_simple_polygon_shader__WEBPACK_IMPORTED_MODULE_1__["SimplePolygonShader"]() : new _shared_shader_polygon_fancy_polygon_shader__WEBPACK_IMPORTED_MODULE_0__["FancyPolygonShader"](options.interpolation);
    const dataMapper = isSimple ? _vertex_data_mapper_simple_polygons_to_shader_buffers__WEBPACK_IMPORTED_MODULE_5__["simplePolygonsToShaderBuffers"] : _vertex_data_mapper_fancy_polygons_to_shader_buffers__WEBPACK_IMPORTED_MODULE_6__["fancyPolygonsToShaderBuffers"];
    const threshold = options.tileThreshold != null ? options.tileThreshold : 10000;
    return new _renderer_switch_renderer__WEBPACK_IMPORTED_MODULE_2__["SwitchRenderer"]([
        {
            renderer: new _renderer_shader_renderer__WEBPACK_IMPORTED_MODULE_3__["ShaderRenderer"](shader, dataMapper),
            condition: data => data.features.length < threshold
        },
        {
            renderer: new _renderer_tiled_renderer__WEBPACK_IMPORTED_MODULE_4__["TiledRenderer"](new _renderer_shader_renderer__WEBPACK_IMPORTED_MODULE_3__["ShaderRenderer"](shader, dataMapper), options),
            condition: data => data.features.length >= threshold
        }
    ]);
}


/***/ }),

/***/ "./src/static-data/renderer/shader-renderer.ts":
/*!*****************************************************!*\
  !*** ./src/static-data/renderer/shader-renderer.ts ***!
  \*****************************************************/
/*! exports provided: ShaderRenderer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderRenderer", function() { return ShaderRenderer; });
/* harmony import */ var _shared_shader_shader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/shader/shader */ "./src/shared/shader/shader.ts");

class ShaderRenderer {
    constructor(shader, vertexDataMapper) {
        this.shader = shader;
        this.vertexDataMapper = vertexDataMapper;
        this.program = null;
        this.arrayBuffer = null;
        this.elementArrayBuffer = null;
        this.array = new Float32Array([]);
        this.elementArray = null;
    }
    setDataAndStyle(data, styleOption) {
        const arrays = this.vertexDataMapper(data, styleOption);
        this.array = arrays.array;
        this.elementArray = arrays.elementArray;
    }
    clearData() {
        this.array = new Float32Array([]);
        this.elementArray = null;
    }
    initialise(map, gl) {
        this.program = Object(_shared_shader_shader__WEBPACK_IMPORTED_MODULE_0__["createShaderProgram"])(gl, this.shader.vertexSource, this.shader.fragmentSource);
        this.arrayBuffer = gl.createBuffer();
        this.elementArrayBuffer = gl.createBuffer();
    }
    dispose(map, gl) {
        gl.deleteBuffer(this.elementArrayBuffer);
        gl.deleteBuffer(this.arrayBuffer);
        gl.deleteProgram(this.program);
    }
    prerender() {
    }
    render(gl, matrix) {
        if (this.program == null) {
            throw Error('ShaderRenderer can not render before it is initialised.');
        }
        gl.enable(gl.BLEND);
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        gl.useProgram(this.program);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.arrayBuffer);
        const cleanAttributes = this.shader.configureAttributes(gl, this.program);
        gl.bufferData(gl.ARRAY_BUFFER, this.array, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        this.shader.setUniforms(gl, this.program, matrix);
        if (this.elementArray == null) {
            gl.drawArrays(this.shader.getPrimitiveType(gl), 0, this.array.length / this.shader.getArrayBufferElementsPerVertex());
        }
        else {
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.elementArrayBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.elementArray, gl.STATIC_DRAW);
            gl.drawElements(this.shader.getPrimitiveType(gl), this.elementArray.length, gl.UNSIGNED_INT, 0);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        }
        cleanAttributes();
    }
}


/***/ }),

/***/ "./src/static-data/renderer/switch-renderer.ts":
/*!*****************************************************!*\
  !*** ./src/static-data/renderer/switch-renderer.ts ***!
  \*****************************************************/
/*! exports provided: SwitchRenderer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SwitchRenderer", function() { return SwitchRenderer; });
class SwitchRenderer {
    constructor(options) {
        this.options = options;
        this.map = null;
        this.gl = null;
        this.currentOption = null;
    }
    setDataAndStyle(data, styleOption) {
        const currentOption = this.currentOption;
        if (currentOption == null || !currentOption.condition(data)) {
            const newOption = this.options.find(option => option.condition(data));
            if (newOption !== currentOption) {
                if (currentOption != null) {
                    currentOption.renderer.clearData();
                }
                if (this.map != null && this.gl != null) {
                    if (currentOption != null) {
                        currentOption.renderer.dispose(this.map, this.gl);
                    }
                    if (newOption != null) {
                        newOption.renderer.initialise(this.map, this.gl);
                    }
                }
                this.currentOption = newOption != null ? newOption : null;
            }
        }
        if (this.currentOption != null) {
            this.currentOption.renderer.setDataAndStyle(data, styleOption);
        }
    }
    clearData() {
        if (this.currentOption != null) {
            this.currentOption.renderer.clearData();
        }
    }
    initialise(map, gl) {
        if (this.currentOption != null) {
            this.currentOption.renderer.initialise(map, gl);
        }
        this.map = map;
        this.gl = gl;
    }
    dispose(map, gl) {
        this.gl = null;
        this.map = null;
        if (this.currentOption != null) {
            this.currentOption.renderer.dispose(map, gl);
        }
    }
    prerender(gl, matrix) {
        if (this.currentOption != null) {
            this.currentOption.renderer.prerender(gl, matrix);
        }
    }
    render(gl, matrix) {
        if (this.currentOption != null) {
            this.currentOption.renderer.render(gl, matrix);
        }
    }
}


/***/ }),

/***/ "./src/static-data/renderer/tiled-renderer.ts":
/*!****************************************************!*\
  !*** ./src/static-data/renderer/tiled-renderer.ts ***!
  \****************************************************/
/*! exports provided: TiledRenderer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TiledRenderer", function() { return TiledRenderer; });
/* harmony import */ var _shared_geometry_functions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/geometry-functions */ "./src/shared/geometry-functions.ts");
/* harmony import */ var _shared_tile_tile_renderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/tile/tile-renderer */ "./src/shared/tile/tile-renderer.ts");


class TiledRenderer {
    constructor(renderer, options) {
        this.renderer = renderer;
        this.dataBounds = {
            minX: Infinity,
            minY: Infinity,
            maxX: -Infinity,
            maxY: -Infinity
        };
        this.tileRenderer = new _shared_tile_tile_renderer__WEBPACK_IMPORTED_MODULE_1__["TileRenderer"](renderer, options);
    }
    setDataAndStyle(data, styleOption) {
        Object(_shared_geometry_functions__WEBPACK_IMPORTED_MODULE_0__["findFeatureCollectionBounds"])(this.dataBounds, data);
        this.renderer.setDataAndStyle(data, styleOption);
        this.tileRenderer.markAllTilesOutdated();
    }
    clearData() {
        this.renderer.clearData();
        this.tileRenderer.markAllTilesOutdated();
    }
    initialise(map, gl) {
        this.tileRenderer.initialise(map, gl);
    }
    dispose(map, gl) {
        this.tileRenderer.dispose(map, gl);
    }
    prerender() {
    }
    render(gl, matrix) {
        this.tileRenderer.render(gl, matrix, this.dataBounds);
    }
}


/***/ }),

/***/ "./src/static-data/static-data-layer.ts":
/*!**********************************************!*\
  !*** ./src/static-data/static-data-layer.ts ***!
  \**********************************************/
/*! exports provided: StaticDataLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticDataLayer", function() { return StaticDataLayer; });
/* harmony import */ var _shared_visibility__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/visibility */ "./src/shared/visibility.ts");

class StaticDataLayer {
    constructor(options) {
        this.options = options;
        this.map = null;
        this.data = null;
        this.styleOption = undefined;
        this.visibility = true;
    }
    get id() {
        return this.options.id;
    }
    get renderingMode() {
        if (this.options.renderingMode == null) {
            return '2d';
        }
        return this.options.renderingMode;
    }
    get type() {
        return 'custom';
    }
    setDataAndStyle(data, styleOption) {
        this.data = data;
        this.styleOption = styleOption;
        this.options.renderer.setDataAndStyle(data, styleOption);
        if (this.options.clickProvider != null) {
            this.options.clickProvider.setData(data);
        }
        if (this.map != null) {
            this.map.triggerRepaint();
        }
    }
    setData(data) {
        this.setDataAndStyle(data, this.styleOption);
    }
    setStyle(styleOption) {
        this.styleOption = styleOption;
        if (this.data == null) {
            return;
        }
        this.options.renderer.setDataAndStyle(this.data, styleOption);
        if (this.map != null) {
            this.map.triggerRepaint();
        }
    }
    clearData() {
        this.data = null;
        this.options.renderer.clearData();
        if (this.options.clickProvider != null) {
            this.options.clickProvider.clearData();
        }
        if (this.map != null) {
            this.map.triggerRepaint();
        }
    }
    setVisibility(visibility) {
        this.visibility = visibility;
        if (this.options.clickProvider != null) {
            this.options.clickProvider.setVisibility(visibility);
        }
        if (this.map != null) {
            this.map.triggerRepaint();
        }
    }
    isVisible() {
        return Object(_shared_visibility__WEBPACK_IMPORTED_MODULE_0__["resolveVisibility"])(this.visibility, this.map);
    }
    onAdd(map, gl) {
        gl.getExtension('OES_element_index_uint');
        this.map = map;
        this.options.renderer.initialise(map, gl);
        if (this.options.clickProvider != null) {
            this.options.clickProvider.initialise(map);
        }
    }
    onRemove(map, gl) {
        this.map = null;
        this.options.renderer.dispose(map, gl);
        if (this.options.clickProvider != null) {
            this.options.clickProvider.dispose(map);
        }
    }
    prerender(gl, matrix) {
        if (this.isVisible()) {
            this.options.renderer.prerender(gl, matrix);
        }
    }
    render(gl, matrix) {
        if (this.isVisible()) {
            this.options.renderer.render(gl, matrix);
        }
    }
}


/***/ }),

/***/ "./src/static-data/vertex-data-mapper/fancy-lines-to-shader-buffers.ts":
/*!*****************************************************************************!*\
  !*** ./src/static-data/vertex-data-mapper/fancy-lines-to-shader-buffers.ts ***!
  \*****************************************************************************/
/*! exports provided: fancyLinesToShaderBuffers */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fancyLinesToShaderBuffers", function() { return fancyLinesToShaderBuffers; });
/* harmony import */ var _shared_styles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/styles */ "./src/shared/styles.ts");
/* harmony import */ var _shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/geometry-functions */ "./src/shared/geometry-functions.ts");


function fancyLinesToShaderBuffers(data, styleOption) {
    const array = [];
    const elementArray = [];
    let currentIndex = 0;
    function processSingleLine(coords, style) {
        if (coords.length < 2) {
            return;
        }
        for (let i = 0; i < coords.length; i++) {
            const currentX = Object(_shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__["transformX"])(coords[i][0]);
            const currentY = Object(_shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__["transformY"])(coords[i][1]);
            let previousX, previousY, nextX, nextY;
            if (i === 0) {
                nextX = Object(_shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__["transformX"])(coords[i + 1][0]);
                nextY = Object(_shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__["transformY"])(coords[i + 1][1]);
                previousX = 2 * currentX - nextX;
                previousY = 2 * currentY - nextY;
            }
            else if (i === coords.length - 1) {
                previousX = Object(_shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__["transformX"])(coords[i - 1][0]);
                previousY = Object(_shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__["transformY"])(coords[i - 1][1]);
                nextX = 2 * currentX - previousX;
                nextY = 2 * currentY - previousY;
            }
            else {
                previousX = Object(_shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__["transformX"])(coords[i - 1][0]);
                previousY = Object(_shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__["transformY"])(coords[i - 1][1]);
                nextX = Object(_shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__["transformX"])(coords[i + 1][0]);
                nextY = Object(_shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__["transformY"])(coords[i + 1][1]);
            }
            const cosAngle = Object(_shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__["cosOfPointsAngle"])(previousX, previousY, currentX, currentY, nextX, nextY);
            if (cosAngle < 0.8) {
                array.push(previousX, previousY, currentX, currentY, nextX, nextY, style.size, style.outlineSize, style.color.r, style.color.g, style.color.b, style.opacity, style.outlineColor.r, style.outlineColor.g, style.outlineColor.b, style.outlineOpacity, previousX, previousY, currentX, currentY, nextX, nextY, -style.size, -style.outlineSize, style.color.r, style.color.g, style.color.b, style.opacity, style.outlineColor.r, style.outlineColor.g, style.outlineColor.b, style.outlineOpacity);
                if (i !== 0) {
                    elementArray.push(currentIndex, currentIndex - 2, currentIndex - 1, currentIndex, currentIndex - 1, currentIndex + 1);
                }
                currentIndex += 2;
            }
            else {
                const fakePreviousX = 2 * currentX - nextX;
                const fakePreviousY = 2 * currentY - nextY;
                const fakeNextX = 2 * currentX - previousX;
                const fakeNextY = 2 * currentY - previousY;
                array.push(previousX, previousY, currentX, currentY, fakeNextX, fakeNextY, style.size, style.outlineSize, style.color.r, style.color.g, style.color.b, style.opacity, style.outlineColor.r, style.outlineColor.g, style.outlineColor.b, style.outlineOpacity, previousX, previousY, currentX, currentY, fakeNextX, fakeNextY, -style.size, -style.outlineSize, style.color.r, style.color.g, style.color.b, style.opacity, style.outlineColor.r, style.outlineColor.g, style.outlineColor.b, style.outlineOpacity, fakePreviousX, fakePreviousY, currentX, currentY, nextX, nextY, style.size, style.outlineSize, style.color.r, style.color.g, style.color.b, style.opacity, style.outlineColor.r, style.outlineColor.g, style.outlineColor.b, style.outlineOpacity, fakePreviousX, fakePreviousY, currentX, currentY, nextX, nextY, -style.size, -style.outlineSize, style.color.r, style.color.g, style.color.b, style.opacity, style.outlineColor.r, style.outlineColor.g, style.outlineColor.b, style.outlineOpacity);
                if (i !== 0) {
                    elementArray.push(currentIndex, currentIndex - 2, currentIndex - 1, currentIndex, currentIndex - 1, currentIndex + 1);
                }
                currentIndex += 4;
            }
        }
    }
    const style = {};
    for (const feature of data.features) {
        Object(_shared_styles__WEBPACK_IMPORTED_MODULE_0__["resolveLineStyle"])(style, feature, styleOption);
        if (feature.geometry.type === 'LineString') {
            const geometry = feature.geometry;
            processSingleLine(geometry.coordinates, style);
        }
        else if (feature.geometry.type === 'MultiLineString') {
            const geometry = feature.geometry;
            for (const coords of geometry.coordinates) {
                processSingleLine(coords, style);
            }
        }
    }
    return {
        array: new Float32Array(array),
        elementArray: new Int32Array(elementArray)
    };
}


/***/ }),

/***/ "./src/static-data/vertex-data-mapper/fancy-points-to-shader-buffers.ts":
/*!******************************************************************************!*\
  !*** ./src/static-data/vertex-data-mapper/fancy-points-to-shader-buffers.ts ***!
  \******************************************************************************/
/*! exports provided: fancyPointsToShaderBuffers */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fancyPointsToShaderBuffers", function() { return fancyPointsToShaderBuffers; });
/* harmony import */ var _shared_styles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/styles */ "./src/shared/styles.ts");
/* harmony import */ var _shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/geometry-functions */ "./src/shared/geometry-functions.ts");


function fancyPointsToShaderBuffers(data, styleOption) {
    const array = [];
    function processSinglePoint(coords, style) {
        array.push(Object(_shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__["transformX"])(coords[0]), Object(_shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__["transformY"])(coords[1]), style.size, style.color.r, style.color.g, style.color.b, style.opacity, style.outlineSize, style.outlineColor.r, style.outlineColor.g, style.outlineColor.b, style.outlineOpacity);
    }
    const style = {};
    for (const feature of data.features) {
        Object(_shared_styles__WEBPACK_IMPORTED_MODULE_0__["resolvePointStyle"])(style, feature, styleOption);
        if (feature.geometry.type === 'Point') {
            const geometry = feature.geometry;
            processSinglePoint(geometry.coordinates, style);
        }
        else if (feature.geometry.type === 'MultiPoint') {
            const geometry = feature.geometry;
            for (const coords of geometry.coordinates) {
                processSinglePoint(coords, style);
            }
        }
    }
    return {
        array: new Float32Array(array),
        elementArray: null
    };
}


/***/ }),

/***/ "./src/static-data/vertex-data-mapper/fancy-polygons-to-shader-buffers.ts":
/*!********************************************************************************!*\
  !*** ./src/static-data/vertex-data-mapper/fancy-polygons-to-shader-buffers.ts ***!
  \********************************************************************************/
/*! exports provided: fancyPolygonsToShaderBuffers */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fancyPolygonsToShaderBuffers", function() { return fancyPolygonsToShaderBuffers; });
/* harmony import */ var _shared_styles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/styles */ "./src/shared/styles.ts");
/* harmony import */ var _shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/geometry-functions */ "./src/shared/geometry-functions.ts");
/* harmony import */ var earcut__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! earcut */ "earcut");
/* harmony import */ var earcut__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(earcut__WEBPACK_IMPORTED_MODULE_2__);



function fancyPolygonsToShaderBuffers(data, styleOption) {
    const array = [];
    const elementArray = [];
    const indexMapper = [];
    let currentIndex = 0;
    function processSinglePolygon(coordinates, style) {
        const transformedCoords = coordinates.map(c => c.map(coords => [Object(_shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__["transformX"])(coords[0]), Object(_shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__["transformY"])(coords[1])]));
        indexMapper.length = 0;
        for (const coords of transformedCoords) {
            for (let i = 0; i < coords.length; i++) {
                const previousIndex = i - 1 >= 0 ? i - 1 : coords.length - 2;
                const nextIndex = i + 1 < coords.length ? i + 1 : 1;
                const currentX = coords[i][0];
                const currentY = coords[i][1];
                const previousX = coords[previousIndex][0];
                const previousY = coords[previousIndex][1];
                const nextX = coords[nextIndex][0];
                const nextY = coords[nextIndex][1];
                const cosAngle = Object(_shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__["cosOfPointsAngle"])(previousX, previousY, currentX, currentY, nextX, nextY);
                if (cosAngle < 0.8) {
                    array.push(previousX, previousY, currentX, currentY, nextX, nextY, style.outlineSize, 0, style.color.r, style.color.g, style.color.b, style.opacity, style.outlineColor.r, style.outlineColor.g, style.outlineColor.b, style.outlineOpacity, previousX, previousY, currentX, currentY, nextX, nextY, style.outlineSize, 1, style.color.r, style.color.g, style.color.b, style.opacity, style.outlineColor.r, style.outlineColor.g, style.outlineColor.b, style.outlineOpacity);
                    if (i !== 0) {
                        elementArray.push(currentIndex, currentIndex - 2, currentIndex - 1, currentIndex, currentIndex - 1, currentIndex + 1);
                    }
                    indexMapper.push(currentIndex);
                    currentIndex += 2;
                }
                else {
                    const fakePreviousX = 2 * currentX - nextX;
                    const fakePreviousY = 2 * currentY - nextY;
                    const fakeNextX = 2 * currentX - previousX;
                    const fakeNextY = 2 * currentY - previousY;
                    array.push(previousX, previousY, currentX, currentY, fakeNextX, fakeNextY, style.outlineSize, 1, style.color.r, style.color.g, style.color.b, style.opacity, style.outlineColor.r, style.outlineColor.g, style.outlineColor.b, style.outlineOpacity, previousX, previousY, currentX, currentY, nextX, nextY, style.outlineSize, 0, style.color.r, style.color.g, style.color.b, style.opacity, style.outlineColor.r, style.outlineColor.g, style.outlineColor.b, style.outlineOpacity, fakePreviousX, fakePreviousY, currentX, currentY, nextX, nextY, style.outlineSize, 1, style.color.r, style.color.g, style.color.b, style.opacity, style.outlineColor.r, style.outlineColor.g, style.outlineColor.b, style.outlineOpacity);
                    if (i !== 0) {
                        elementArray.push(currentIndex + 1, currentIndex - 2, currentIndex - 1, currentIndex + 1, currentIndex - 1, currentIndex, currentIndex, currentIndex + 1, currentIndex + 2);
                    }
                    indexMapper.push(currentIndex + 1);
                    currentIndex += 3;
                }
            }
        }
        const data = earcut__WEBPACK_IMPORTED_MODULE_2___default.a.flatten(transformedCoords);
        const triangles = earcut__WEBPACK_IMPORTED_MODULE_2___default()(data.vertices, data.holes, data.dimensions);
        for (const index of triangles) {
            elementArray.push(indexMapper[index]);
        }
    }
    const style = {};
    for (const feature of data.features) {
        Object(_shared_styles__WEBPACK_IMPORTED_MODULE_0__["resolvePolygonStyle"])(style, feature, styleOption);
        if (feature.geometry.type === 'Polygon') {
            const geometry = feature.geometry;
            processSinglePolygon(geometry.coordinates, style);
        }
        else if (feature.geometry.type === 'MultiPolygon') {
            const geometry = feature.geometry;
            for (const coords of geometry.coordinates) {
                processSinglePolygon(coords, style);
            }
        }
    }
    return {
        array: new Float32Array(array),
        elementArray: new Int32Array(elementArray)
    };
}


/***/ }),

/***/ "./src/static-data/vertex-data-mapper/simple-lines-to-shader-buffers.ts":
/*!******************************************************************************!*\
  !*** ./src/static-data/vertex-data-mapper/simple-lines-to-shader-buffers.ts ***!
  \******************************************************************************/
/*! exports provided: simpleLinesToShaderBuffers */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "simpleLinesToShaderBuffers", function() { return simpleLinesToShaderBuffers; });
/* harmony import */ var _shared_styles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/styles */ "./src/shared/styles.ts");
/* harmony import */ var _shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/geometry-functions */ "./src/shared/geometry-functions.ts");


function simpleLinesToShaderBuffers(data, styleOption) {
    const array = [];
    const elementsArray = [];
    let currentIndex = 0;
    function processSingleLine(coordinates, style) {
        for (let i = 0; i < coordinates.length; i++) {
            const coords = coordinates[i];
            array.push(Object(_shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__["transformX"])(coords[0]), Object(_shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__["transformY"])(coords[1]), style.color.r, style.color.g, style.color.b, style.opacity);
            if (i === 0 || i === coordinates.length - 1) {
                elementsArray.push(currentIndex);
            }
            else {
                elementsArray.push(currentIndex, currentIndex);
            }
            currentIndex++;
        }
    }
    const style = {};
    for (const feature of data.features) {
        Object(_shared_styles__WEBPACK_IMPORTED_MODULE_0__["resolveLineStyle"])(style, feature, styleOption);
        if (feature.geometry.type === 'LineString') {
            const geometry = feature.geometry;
            processSingleLine(geometry.coordinates, style);
        }
        else if (feature.geometry.type === 'MultiLineString') {
            const geometry = feature.geometry;
            for (const coords of geometry.coordinates) {
                processSingleLine(coords, style);
            }
        }
    }
    return {
        array: new Float32Array(array),
        elementArray: new Int32Array(elementsArray)
    };
}


/***/ }),

/***/ "./src/static-data/vertex-data-mapper/simple-points-to-shader-buffers.ts":
/*!*******************************************************************************!*\
  !*** ./src/static-data/vertex-data-mapper/simple-points-to-shader-buffers.ts ***!
  \*******************************************************************************/
/*! exports provided: simplePointsToShaderBuffers */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "simplePointsToShaderBuffers", function() { return simplePointsToShaderBuffers; });
/* harmony import */ var _shared_styles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/styles */ "./src/shared/styles.ts");
/* harmony import */ var _shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/geometry-functions */ "./src/shared/geometry-functions.ts");


function simplePointsToShaderBuffers(data, styleOption) {
    const array = [];
    function processSinglePoint(coords, style) {
        array.push(Object(_shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__["transformX"])(coords[0]), Object(_shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__["transformY"])(coords[1]), style.size, style.color.r, style.color.g, style.color.b, style.opacity);
    }
    const style = {};
    for (const feature of data.features) {
        Object(_shared_styles__WEBPACK_IMPORTED_MODULE_0__["resolvePointStyle"])(style, feature, styleOption);
        if (feature.geometry.type === 'Point') {
            const geometry = feature.geometry;
            processSinglePoint(geometry.coordinates, style);
        }
        else if (feature.geometry.type === 'MultiPoint') {
            const geometry = feature.geometry;
            for (const coords of geometry.coordinates) {
                processSinglePoint(coords, style);
            }
        }
    }
    return {
        array: new Float32Array(array),
        elementArray: null
    };
}


/***/ }),

/***/ "./src/static-data/vertex-data-mapper/simple-polygons-to-shader-buffers.ts":
/*!*********************************************************************************!*\
  !*** ./src/static-data/vertex-data-mapper/simple-polygons-to-shader-buffers.ts ***!
  \*********************************************************************************/
/*! exports provided: simplePolygonsToShaderBuffers */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "simplePolygonsToShaderBuffers", function() { return simplePolygonsToShaderBuffers; });
/* harmony import */ var _shared_styles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/styles */ "./src/shared/styles.ts");
/* harmony import */ var _shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/geometry-functions */ "./src/shared/geometry-functions.ts");
/* harmony import */ var earcut__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! earcut */ "earcut");
/* harmony import */ var earcut__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(earcut__WEBPACK_IMPORTED_MODULE_2__);



function simplePolygonsToShaderBuffers(data, styleOption) {
    const array = [];
    const elementArray = [];
    let indexOffset = 0;
    function processSinglePolygon(coordinates, style) {
        const transformedCoordinates = coordinates.map(c => c.map(coords => [Object(_shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__["transformX"])(coords[0]), Object(_shared_geometry_functions__WEBPACK_IMPORTED_MODULE_1__["transformY"])(coords[1])]));
        const data = earcut__WEBPACK_IMPORTED_MODULE_2___default.a.flatten(transformedCoordinates);
        for (let i = 0; i < data.vertices.length; i += 2) {
            array.push(data.vertices[i], data.vertices[i + 1], style.color.r, style.color.g, style.color.b, style.opacity);
        }
        const triangles = earcut__WEBPACK_IMPORTED_MODULE_2___default()(data.vertices, data.holes, data.dimensions);
        for (const index of triangles) {
            elementArray.push(index + indexOffset);
        }
        indexOffset += data.vertices.length / 2;
    }
    const style = {};
    for (const feature of data.features) {
        Object(_shared_styles__WEBPACK_IMPORTED_MODULE_0__["resolvePolygonStyle"])(style, feature, styleOption);
        if (feature.geometry.type === 'Polygon') {
            const geometry = feature.geometry;
            processSinglePolygon(geometry.coordinates, style);
        }
        else if (feature.geometry.type === 'MultiPolygon') {
            const geometry = feature.geometry;
            for (const coords of geometry.coordinates) {
                processSinglePolygon(coords, style);
            }
        }
    }
    return {
        array: new Float32Array(array),
        elementArray: new Int32Array(elementArray)
    };
}


/***/ }),

/***/ "earcut":
/*!*************************!*\
  !*** external "earcut" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_earcut__;

/***/ }),

/***/ "gl-matrix":
/*!****************************!*\
  !*** external "gl-matrix" ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_gl_matrix__;

/***/ }),

/***/ "kdbush":
/*!*************************!*\
  !*** external "kdbush" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_kdbush__;

/***/ }),

/***/ "rbush":
/*!************************!*\
  !*** external "rbush" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_rbush__;

/***/ })

/******/ });
});
//# sourceMappingURL=index.js.map